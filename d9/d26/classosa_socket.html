<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>cisst-saw: osaSocket Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cisst-saw
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d1/de0/classosa_socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">osaSocket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d1/d3b/osa_socket_8h_source.html">osaSocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for osaSocket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d9/d26/classosa_socket.png" usemap="#osaSocket_map" alt=""/>
  <map id="osaSocket_map" name="osaSocket_map">
<area href="../../d0/d24/classcmn_generic_object.html" title="Base class for high level objects. " alt="cmnGenericObject" shape="rect" coords="0,0,117,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adeb99e6a5b2d4e503e0308ccb9677a00"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00">SocketTypes</a> { <a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00a30ff2c2d5d46158f56ac6d521629612a">UDP</a>, 
<a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00a285ce3d0ac4094f708fa3f7b2f222430">TCP</a>
 }</td></tr>
<tr class="separator:adeb99e6a5b2d4e503e0308ccb9677a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a978ed4ba465032ca6061fa6486464840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a978ed4ba465032ca6061fa6486464840">osaSocket</a> (<a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00">SocketTypes</a> type=<a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00a285ce3d0ac4094f708fa3f7b2f222430">TCP</a>)</td></tr>
<tr class="memdesc:a978ed4ba465032ca6061fa6486464840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a978ed4ba465032ca6061fa6486464840">More...</a><br /></td></tr>
<tr class="separator:a978ed4ba465032ca6061fa6486464840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78099904ded5203835307eac712c4a14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a78099904ded5203835307eac712c4a14">~osaSocket</a> (void)</td></tr>
<tr class="memdesc:a78099904ded5203835307eac712c4a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a78099904ded5203835307eac712c4a14">More...</a><br /></td></tr>
<tr class="separator:a78099904ded5203835307eac712c4a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109a21812219017a15fea0e38aa0c3c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a109a21812219017a15fea0e38aa0c3c6">GetIdentifier</a> (void) const </td></tr>
<tr class="separator:a109a21812219017a15fea0e38aa0c3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac057f23deeeb355089a5f0b36b82c1eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#ac057f23deeeb355089a5f0b36b82c1eb">AssignPort</a> (unsigned short port)</td></tr>
<tr class="memdesc:ac057f23deeeb355089a5f0b36b82c1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the port of a UDP server.  <a href="#ac057f23deeeb355089a5f0b36b82c1eb">More...</a><br /></td></tr>
<tr class="separator:ac057f23deeeb355089a5f0b36b82c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a02b283355bf2beff6217bb2e01c03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a5a02b283355bf2beff6217bb2e01c03a">SetDestination</a> (const std::string &amp;host, unsigned short port)</td></tr>
<tr class="memdesc:a5a02b283355bf2beff6217bb2e01c03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destination address for UDP or TCP socket.  <a href="#a5a02b283355bf2beff6217bb2e01c03a">More...</a><br /></td></tr>
<tr class="separator:a5a02b283355bf2beff6217bb2e01c03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86d6d1c9c1155aa3f6fb5fd396fb2c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#ac86d6d1c9c1155aa3f6fb5fd396fb2c9">SetDestination</a> (const <a class="el" href="../../d2/d1e/structosa_i_pand_port.html">osaIPandPort</a> &amp;ip_port)</td></tr>
<tr class="memdesc:ac86d6d1c9c1155aa3f6fb5fd396fb2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destination address for UDP or TCP socket.  <a href="#ac86d6d1c9c1155aa3f6fb5fd396fb2c9">More...</a><br /></td></tr>
<tr class="separator:ac86d6d1c9c1155aa3f6fb5fd396fb2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f354c34c89fbbd12f3dee0be6787596"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a1f354c34c89fbbd12f3dee0be6787596">GetDestination</a> (std::string &amp;host, unsigned short &amp;port) const </td></tr>
<tr class="memdesc:a1f354c34c89fbbd12f3dee0be6787596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the destination address for UDP or TCP socket. This is particularly useful for programs using UDP because the the Receive method automatically updates the destination based on the address from which the packet was received. Thus, subsequent Send commands will send to this address.  <a href="#a1f354c34c89fbbd12f3dee0be6787596">More...</a><br /></td></tr>
<tr class="separator:a1f354c34c89fbbd12f3dee0be6787596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8030ca721b7d095cf26ca40e6d237a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#aa8030ca721b7d095cf26ca40e6d237a3">GetDestination</a> (<a class="el" href="../../d2/d1e/structosa_i_pand_port.html">osaIPandPort</a> &amp;ip_port) const </td></tr>
<tr class="memdesc:aa8030ca721b7d095cf26ca40e6d237a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the destination address for UDP or TCP socket. This is particularly useful for programs using UDP because the the Receive method automatically updates the destination based on the address from which the packet was received. Thus, subsequent Send commands will send to this address.  <a href="#aa8030ca721b7d095cf26ca40e6d237a3">More...</a><br /></td></tr>
<tr class="separator:aa8030ca721b7d095cf26ca40e6d237a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e1010cd5c499ed8b0b3ab6a43a50cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a26e1010cd5c499ed8b0b3ab6a43a50cd">Connect</a> (void)</td></tr>
<tr class="memdesc:a26e1010cd5c499ed8b0b3ab6a43a50cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the server; required for TCP sockets and should be used after <a class="el" href="../../d9/d26/classosa_socket.html#a5a02b283355bf2beff6217bb2e01c03a" title="Set the destination address for UDP or TCP socket. ">SetDestination()</a>  <a href="#a26e1010cd5c499ed8b0b3ab6a43a50cd">More...</a><br /></td></tr>
<tr class="separator:a26e1010cd5c499ed8b0b3ab6a43a50cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003dbb8706ca2a332b8f2a8187626847"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a003dbb8706ca2a332b8f2a8187626847">Connect</a> (const std::string &amp;host, unsigned short port)</td></tr>
<tr class="memdesc:a003dbb8706ca2a332b8f2a8187626847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the server; required for TCP sockets; includes call to <a class="el" href="../../d9/d26/classosa_socket.html#a5a02b283355bf2beff6217bb2e01c03a" title="Set the destination address for UDP or TCP socket. ">SetDestination()</a>  <a href="#a003dbb8706ca2a332b8f2a8187626847">More...</a><br /></td></tr>
<tr class="separator:a003dbb8706ca2a332b8f2a8187626847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a8bc0002ea1bcdd3c1a48c9f7c1252"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a90a8bc0002ea1bcdd3c1a48c9f7c1252">Connect</a> (const <a class="el" href="../../d2/d1e/structosa_i_pand_port.html">osaIPandPort</a> &amp;ip_port)</td></tr>
<tr class="memdesc:a90a8bc0002ea1bcdd3c1a48c9f7c1252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the server; required for TCP sockets; includes call to <a class="el" href="../../d9/d26/classosa_socket.html#a5a02b283355bf2beff6217bb2e01c03a" title="Set the destination address for UDP or TCP socket. ">SetDestination()</a>  <a href="#a90a8bc0002ea1bcdd3c1a48c9f7c1252">More...</a><br /></td></tr>
<tr class="separator:a90a8bc0002ea1bcdd3c1a48c9f7c1252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a255ce888e52f7be1098f651acacd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#abf9a255ce888e52f7be1098f651acacd">Send</a> (const char *bufsend, unsigned int msglen, double timeoutSec=0.0)</td></tr>
<tr class="memdesc:abf9a255ce888e52f7be1098f651acacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a byte array via the socket.  <a href="#abf9a255ce888e52f7be1098f651acacd">More...</a><br /></td></tr>
<tr class="separator:abf9a255ce888e52f7be1098f651acacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e52036f8cf0a4896e1631696ab8001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#ae0e52036f8cf0a4896e1631696ab8001">Send</a> (const std::string &amp;bufsend, double timeoutSec=0.0)</td></tr>
<tr class="memdesc:ae0e52036f8cf0a4896e1631696ab8001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a string via the socket.  <a href="#ae0e52036f8cf0a4896e1631696ab8001">More...</a><br /></td></tr>
<tr class="separator:ae0e52036f8cf0a4896e1631696ab8001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734960e3f31352ecce882c55638e219b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a734960e3f31352ecce882c55638e219b">SendAsPackets</a> (const char *bufsend, unsigned int msglen, unsigned int packetSize, double timeoutSec=0.0)</td></tr>
<tr class="memdesc:a734960e3f31352ecce882c55638e219b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a byte array via the socket, possibly in multiple packets based on the specified maximum packet_size. This method can be used with both UDP and TCP, though it is intended for UDP.  <a href="#a734960e3f31352ecce882c55638e219b">More...</a><br /></td></tr>
<tr class="separator:a734960e3f31352ecce882c55638e219b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13c453c4f62e562e38a391725992232"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#ac13c453c4f62e562e38a391725992232">SendAsPackets</a> (const std::string &amp;bufsend, unsigned int packetSize, double timeoutSec=0.0)</td></tr>
<tr class="memdesc:ac13c453c4f62e562e38a391725992232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a string via the socket, possibly in multiple packets based on the specified maximum packet_size. This method can be used with both UDP and TCP, though it is intended for UDP (only for reliable UDP connections, since there is no check for missing or out of sequence packets).  <a href="#ac13c453c4f62e562e38a391725992232">More...</a><br /></td></tr>
<tr class="separator:ac13c453c4f62e562e38a391725992232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76241adc0e7a67b5dfae17f81e2728ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a76241adc0e7a67b5dfae17f81e2728ac">Receive</a> (char *bufrecv, unsigned int maxlen, double timeoutSec=0.0)</td></tr>
<tr class="memdesc:a76241adc0e7a67b5dfae17f81e2728ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a byte array via the socket.  <a href="#a76241adc0e7a67b5dfae17f81e2728ac">More...</a><br /></td></tr>
<tr class="separator:a76241adc0e7a67b5dfae17f81e2728ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbcb441431d78b8887c8c6af9998f7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#afcbcb441431d78b8887c8c6af9998f7e">ReceiveAsPackets</a> (std::string &amp;bufrecv, char *packetBuffer, unsigned int packetSize, double timeoutStartSec=0.0, double timeoutNextSec=0.0)</td></tr>
<tr class="memdesc:afcbcb441431d78b8887c8c6af9998f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a string via the socket, possibly in multiple packets. This method can be used with both UDP and TCP, though it is intended for UDP (only for reliable UDP connections, since there is no check for missing or out of sequence packets).  <a href="#afcbcb441431d78b8887c8c6af9998f7e">More...</a><br /></td></tr>
<tr class="separator:afcbcb441431d78b8887c8c6af9998f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf1869eba7f202d3955bdd58de79503"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#acaf1869eba7f202d3955bdd58de79503">Close</a> (void)</td></tr>
<tr class="memdesc:acaf1869eba7f202d3955bdd58de79503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="#acaf1869eba7f202d3955bdd58de79503">More...</a><br /></td></tr>
<tr class="separator:acaf1869eba7f202d3955bdd58de79503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe0c123217596854f4f912b04d4e2f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#aabe0c123217596854f4f912b04d4e2f2">IsConnected</a> (void)</td></tr>
<tr class="separator:aabe0c123217596854f4f912b04d4e2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcmn_generic_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcmn_generic_object')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d0/d24/classcmn_generic_object.html">cmnGenericObject</a></td></tr>
<tr class="memitem:ac46f55295b1cef7277f6083a546329af inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#ac46f55295b1cef7277f6083a546329af">~cmnGenericObject</a> (void)</td></tr>
<tr class="separator:ac46f55295b1cef7277f6083a546329af inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e9145a0ed0711ac0c0c3edd37b673a inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../de/dd5/classcmn_class_services_base.html">cmnClassServicesBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#ac1e9145a0ed0711ac0c0c3edd37b673a">Services</a> (void) const =0</td></tr>
<tr class="separator:ac1e9145a0ed0711ac0c0c3edd37b673a inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7507c3e8f396099599595a0e7f37a89e inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#a7507c3e8f396099599595a0e7f37a89e">ReconstructFrom</a> (const <a class="el" href="../../d0/d24/classcmn_generic_object.html">cmnGenericObject</a> &amp;other)</td></tr>
<tr class="separator:a7507c3e8f396099599595a0e7f37a89e inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204a55fc8b83c33d241854a77fb5fe0c inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#a204a55fc8b83c33d241854a77fb5fe0c">ToString</a> (void) const </td></tr>
<tr class="separator:a204a55fc8b83c33d241854a77fb5fe0c inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b71ce10573cceff0446748432f45df inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#ac2b71ce10573cceff0446748432f45df">ToStream</a> (std::ostream &amp;outputStream) const </td></tr>
<tr class="separator:ac2b71ce10573cceff0446748432f45df inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8810f78cd3621f37c5e9bbc4679795ce inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#a8810f78cd3621f37c5e9bbc4679795ce">ToStreamRaw</a> (std::ostream &amp;outputStream, const char delimiter= ' ', bool headerOnly=false, const std::string &amp;headerPrefix=&quot;&quot;) const </td></tr>
<tr class="separator:a8810f78cd3621f37c5e9bbc4679795ce inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a64299c2410e2bb8e9ff274daad3ed inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#a41a64299c2410e2bb8e9ff274daad3ed">FromStreamRaw</a> (std::istream &amp;inputStream, const char delimiter= ' ')</td></tr>
<tr class="separator:a41a64299c2410e2bb8e9ff274daad3ed inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ded5b1c123d923040cd17071f95d8ca inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#a8ded5b1c123d923040cd17071f95d8ca">SerializeRaw</a> (std::ostream &amp;outputStream) const </td></tr>
<tr class="separator:a8ded5b1c123d923040cd17071f95d8ca inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19babea5bb663491b7ff98ef6fce972f inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#a19babea5bb663491b7ff98ef6fce972f">DeSerializeRaw</a> (std::istream &amp;inputStream)</td></tr>
<tr class="separator:a19babea5bb663491b7ff98ef6fce972f inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b122c39a158861bcda067fd5899dcb inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d6/dcd/classcmn_logger.html#a7d192777882d1dc6bb48ceac0b4e65bb">cmnLogger::StreamBufType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#a93b122c39a158861bcda067fd5899dcb">GetLogMultiplexer</a> (void) const </td></tr>
<tr class="separator:a93b122c39a158861bcda067fd5899dcb inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e43bf8fd4a1eb17e210b838d8f553c inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#ae4e43bf8fd4a1eb17e210b838d8f553c">ScalarNumber</a> (void) const </td></tr>
<tr class="separator:ae4e43bf8fd4a1eb17e210b838d8f553c inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76247d102d2265d3fb6370fbdc22848 inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#ac76247d102d2265d3fb6370fbdc22848">ScalarNumberIsFixed</a> (void) const </td></tr>
<tr class="separator:ac76247d102d2265d3fb6370fbdc22848 inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8869d94fb0195db6ee04bafd9a947f8 inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#ae8869d94fb0195db6ee04bafd9a947f8">Scalar</a> (const size_t <a class="el" href="../../dc/d31/cmn_portability_8h.html#a021894e2626935fa2305434b1e893ff6">CMN_UNUSED</a>(index)) const   throw (std::out_of_range)</td></tr>
<tr class="separator:ae8869d94fb0195db6ee04bafd9a947f8 inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb580fededf2ffd05fd38467fa22bf05 inherit pub_methods_classcmn_generic_object"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d24/classcmn_generic_object.html#adb580fededf2ffd05fd38467fa22bf05">ScalarDescription</a> (const size_t <a class="el" href="../../dc/d31/cmn_portability_8h.html#a021894e2626935fa2305434b1e893ff6">CMN_UNUSED</a>(index), const std::string &amp;<a class="el" href="../../dc/d31/cmn_portability_8h.html#a021894e2626935fa2305434b1e893ff6">CMN_UNUSED</a>(userDescription)) const </td></tr>
<tr class="separator:adb580fededf2ffd05fd38467fa22bf05 inherit pub_methods_classcmn_generic_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a733e1bbf1236424b9345c56d4436b9f4"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a733e1bbf1236424b9345c56d4436b9f4">GetLocalhostIP</a> (void)</td></tr>
<tr class="separator:a733e1bbf1236424b9345c56d4436b9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4819601ae4e72f6695dc61781b4fc73c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a4819601ae4e72f6695dc61781b4fc73c">GetLocalhostIP</a> (std::vector&lt; std::string &gt; &amp;IPaddress)</td></tr>
<tr class="memdesc:a4819601ae4e72f6695dc61781b4fc73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve IP address of the localhost as string from each network interface (which may be more than two)  <a href="#a4819601ae4e72f6695dc61781b4fc73c">More...</a><br /></td></tr>
<tr class="separator:a4819601ae4e72f6695dc61781b4fc73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad52fa55231168bf731ed495cc89405ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#ad52fa55231168bf731ed495cc89405ff">osaSocket</a> (void *socketFDPtr)</td></tr>
<tr class="memdesc:ad52fa55231168bf731ed495cc89405ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/d83/classosa_socket_server.html">osaSocketServer</a> constructor (for use by <a class="el" href="../../dd/d83/classosa_socket_server.html">osaSocketServer</a>)  <a href="#ad52fa55231168bf731ed495cc89405ff">More...</a><br /></td></tr>
<tr class="separator:ad52fa55231168bf731ed495cc89405ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e6b0d1fe72490b6163fa439c27a10b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#a98e6b0d1fe72490b6163fa439c27a10b">GetIP</a> (const std::string &amp;host) const </td></tr>
<tr class="separator:a98e6b0d1fe72490b6163fa439c27a10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac893ce4c18feac9b627df95993156482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00">SocketTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#ac893ce4c18feac9b627df95993156482">SocketType</a></td></tr>
<tr class="separator:ac893ce4c18feac9b627df95993156482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b18a862994f6498868186a44d28793"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#aa2b18a862994f6498868186a44d28793">SocketFD</a></td></tr>
<tr class="separator:aa2b18a862994f6498868186a44d28793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44f88953d932cd97a9c772155d21e37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#ab44f88953d932cd97a9c772155d21e37">Connected</a></td></tr>
<tr class="separator:ab44f88953d932cd97a9c772155d21e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe48006d88cc6ef49f926f1eab169439"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d26/classosa_socket.html#abe48006d88cc6ef49f926f1eab169439">osaSocketServer</a></td></tr>
<tr class="separator:abe48006d88cc6ef49f926f1eab169439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="adeb99e6a5b2d4e503e0308ccb9677a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00">osaSocket::SocketTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="adeb99e6a5b2d4e503e0308ccb9677a00a30ff2c2d5d46158f56ac6d521629612a"></a>UDP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adeb99e6a5b2d4e503e0308ccb9677a00a285ce3d0ac4094f708fa3f7b2f222430"></a>TCP&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a978ed4ba465032ca6061fa6486464840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osaSocket::osaSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00">SocketTypes</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00a285ce3d0ac4094f708fa3f7b2f222430">TCP</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a78099904ded5203835307eac712c4a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osaSocket::~osaSocket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="ad52fa55231168bf731ed495cc89405ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">osaSocket::osaSocket </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>socketFDPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../dd/d83/classosa_socket_server.html">osaSocketServer</a> constructor (for use by <a class="el" href="../../dd/d83/classosa_socket_server.html">osaSocketServer</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Void</td><td>pointer is used to her avoid including WinSock2.h, the pointer is cast to proper socket in cpp file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac057f23deeeb355089a5f0b36b82c1eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::AssignPort </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the port of a UDP server. </p>

</div>
</div>
<a class="anchor" id="acaf1869eba7f202d3955bdd58de79503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::Close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the socket. </p>
<dl class="section return"><dt>Returns</dt><dd>False if close fails </dd></dl>

</div>
</div>
<a class="anchor" id="a26e1010cd5c499ed8b0b3ab6a43a50cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::Connect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the server; required for TCP sockets and should be used after <a class="el" href="../../d9/d26/classosa_socket.html#a5a02b283355bf2beff6217bb2e01c03a" title="Set the destination address for UDP or TCP socket. ">SetDestination()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>true if the connection was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a003dbb8706ca2a332b8f2a8187626847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::Connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the server; required for TCP sockets; includes call to <a class="el" href="../../d9/d26/classosa_socket.html#a5a02b283355bf2beff6217bb2e01c03a" title="Set the destination address for UDP or TCP socket. ">SetDestination()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Server's hostname or IP address (e.g. localhost, 127.0.0.1) </td></tr>
    <tr><td class="paramname">port</td><td>Server's port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connection was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a90a8bc0002ea1bcdd3c1a48c9f7c1252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::Connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d1e/structosa_i_pand_port.html">osaIPandPort</a> &amp;&#160;</td>
          <td class="paramname"><em>ip_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the server; required for TCP sockets; includes call to <a class="el" href="../../d9/d26/classosa_socket.html#a5a02b283355bf2beff6217bb2e01c03a" title="Set the destination address for UDP or TCP socket. ">SetDestination()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_port</td><td>Server's hostname or IP address (e.g. localhost, 127.0.0.1) and port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connection was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a1f354c34c89fbbd12f3dee0be6787596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::GetDestination </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the destination address for UDP or TCP socket. This is particularly useful for programs using UDP because the the Receive method automatically updates the destination based on the address from which the packet was received. Thus, subsequent Send commands will send to this address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Reference for returning server's IP address (e.g. "127.0.0.1") </td></tr>
    <tr><td class="paramname">port</td><td>Reference for returning server's port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if destination address was returned </dd></dl>

</div>
</div>
<a class="anchor" id="aa8030ca721b7d095cf26ca40e6d237a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::GetDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d1e/structosa_i_pand_port.html">osaIPandPort</a> &amp;&#160;</td>
          <td class="paramname"><em>ip_port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the destination address for UDP or TCP socket. This is particularly useful for programs using UDP because the the Receive method automatically updates the destination based on the address from which the packet was received. Thus, subsequent Send commands will send to this address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_port</td><td>Reference for returning server's IP address (e.g. "127.0.0.1") and port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if destination address was returned </dd></dl>

</div>
</div>
<a class="anchor" id="a109a21812219017a15fea0e38aa0c3c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::GetIdentifier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Socket file descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="a98e6b0d1fe72490b6163fa439c27a10b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long osaSocket::GetIP </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>IP address (as a number) for the given host </dd></dl>

</div>
</div>
<a class="anchor" id="a733e1bbf1236424b9345c56d4436b9f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string osaSocket::GetLocalhostIP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first IP address of the localhost as a string </dd></dl>

</div>
</div>
<a class="anchor" id="a4819601ae4e72f6695dc61781b4fc73c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int osaSocket::GetLocalhostIP </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>IPaddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve IP address of the localhost as string from each network interface (which may be more than two) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IPaddresses</td><td>container for IP address as string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of IP address retrieved with IPaddresses filled </dd></dl>

</div>
</div>
<a class="anchor" id="aabe0c123217596854f4f912b04d4e2f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::IsConnected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\ brief Connection state (only works for TCP) </p><dl class="section return"><dt>Returns</dt><dd>Returns true if the socket thinks it is connected </dd></dl>

</div>
</div>
<a class="anchor" id="a76241adc0e7a67b5dfae17f81e2728ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::Receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufrecv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeoutSec</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a byte array via the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufrecv</td><td>Buffer to store received data </td></tr>
    <tr><td class="paramname">maxlen</td><td>Maximum number of bytes to receive </td></tr>
    <tr><td class="paramname">timeoutSec</td><td>Timeout in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes received. 0 if timeout is reached and/or no data is received. </dd></dl>

</div>
</div>
<a class="anchor" id="afcbcb441431d78b8887c8c6af9998f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::ReceiveAsPackets </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>bufrecv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>packetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>packetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeoutStartSec</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeoutNextSec</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a string via the socket, possibly in multiple packets. This method can be used with both UDP and TCP, though it is intended for UDP (only for reliable UDP connections, since there is no check for missing or out of sequence packets). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufrecv</td><td>String to store received data </td></tr>
    <tr><td class="paramname">packetBuffer</td><td>Buffer to store one packet </td></tr>
    <tr><td class="paramname">packetSize</td><td>Maximum packet size, should equal sizeof(packetBuffer) </td></tr>
    <tr><td class="paramname">timeoutStartSec</td><td>Timeout for receiving first packet, in seconds </td></tr>
    <tr><td class="paramname">timeoutNextSec</td><td>Timeout for receiving subsequent packets (after first), in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes received. 0 if timeout is reached and/or no data is received. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It can be difficult to determine when a complete set of packets has been received. This function is intended primarily to receive the packet stream produced by SendAsPackets, so it terminates reception in the following cases: (1) when a received packet is smaller than the specified packetSize, (2) on any socket error, and (3) when a timeout occurs. The first condition is best, since it avoids the possibility of appending data from an unrelated packet. Thus, the caller can ensure that the total number of bytes transmitted is not a multiple of the packetSize (e.g., by appending an extra byte). </dd></dl>

</div>
</div>
<a class="anchor" id="abf9a255ce888e52f7be1098f651acacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bufsend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>msglen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeoutSec</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a byte array via the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufsend</td><td>Buffer holding bytes to be sent </td></tr>
    <tr><td class="paramname">msglen</td><td>Number of bytes to send </td></tr>
    <tr><td class="paramname">timeoutSec</td><td>is the longest time we should wait to send something </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent (-1 if error) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since this is a nonblocking call the socket might not be ready to send right away so a short timeout will help in cases when large amount of data is sent around. If the socket is not ready within the timeout then the connection will be closed </dd></dl>

</div>
</div>
<a class="anchor" id="ae0e52036f8cf0a4896e1631696ab8001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bufsend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeoutSec</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a string via the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufsend</td><td>String to be sent </td></tr>
    <tr><td class="paramname">timeoutSec</td><td>is the longest time we should wait to send something </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent (-1 if error) </dd></dl>

</div>
</div>
<a class="anchor" id="a734960e3f31352ecce882c55638e219b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::SendAsPackets </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bufsend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>msglen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>packetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeoutSec</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a byte array via the socket, possibly in multiple packets based on the specified maximum packet_size. This method can be used with both UDP and TCP, though it is intended for UDP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufsend</td><td>Buffer holding bytes to be sent </td></tr>
    <tr><td class="paramname">packetSize</td><td>Maximum packet size </td></tr>
    <tr><td class="paramname">timeoutSec</td><td>is the longest time we should wait to send something </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent (-1 if error) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function aborts if any error occurs and returns the number of bytes actually sent (if any). </dd></dl>

</div>
</div>
<a class="anchor" id="ac13c453c4f62e562e38a391725992232"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::SendAsPackets </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bufsend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>packetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeoutSec</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a string via the socket, possibly in multiple packets based on the specified maximum packet_size. This method can be used with both UDP and TCP, though it is intended for UDP (only for reliable UDP connections, since there is no check for missing or out of sequence packets). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufsend</td><td>String to be sent </td></tr>
    <tr><td class="paramname">packetSize</td><td>Maximum packet size </td></tr>
    <tr><td class="paramname">timeoutSec</td><td>is the longest time we should wait to send something </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent (-1 if error) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function aborts if any error occurs and returns the number of bytes actually sent (if any). </dd></dl>

</div>
</div>
<a class="anchor" id="a5a02b283355bf2beff6217bb2e01c03a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osaSocket::SetDestination </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the destination address for UDP or TCP socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Server's hostname or IP address (e.g. localhost, 127.0.0.1) </td></tr>
    <tr><td class="paramname">port</td><td>Server's port number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac86d6d1c9c1155aa3f6fb5fd396fb2c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void osaSocket::SetDestination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d1e/structosa_i_pand_port.html">osaIPandPort</a> &amp;&#160;</td>
          <td class="paramname"><em>ip_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the destination address for UDP or TCP socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_port</td><td>Server's hostname or IP address (e.g. localhost, 127.0.0.1) and port number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="abe48006d88cc6ef49f926f1eab169439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../dd/d83/classosa_socket_server.html">osaSocketServer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab44f88953d932cd97a9c772155d21e37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool osaSocket::Connected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa2b18a862994f6498868186a44d28793"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int osaSocket::SocketFD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac893ce4c18feac9b627df95993156482"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d26/classosa_socket.html#adeb99e6a5b2d4e503e0308ccb9677a00">SocketTypes</a> osaSocket::SocketType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/anton/devel/cisst-saw/cisst/cisstOSAbstraction/<a class="el" href="../../d1/d3b/osa_socket_8h_source.html">osaSocket.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
