\hypertarget{classnmr_s_v_d_dynamic_data}{}\section{nmr\+S\+V\+D\+Dynamic\+Data Class Reference}
\label{classnmr_s_v_d_dynamic_data}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}


Data for S\+V\+D problem (Dynamic).  




{\ttfamily \#include $<$nmr\+S\+V\+D.\+h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnmr_s_v_d_dynamic_data_1_1_friend}{Friend}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{namespacevct_a3e2935e13aac4500965e00d30565775b}{vct\+::size\+\_\+type} \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type}
\item 
typedef \hyperlink{classvct_fixed_size_vector}{vct\+Fixed\+Size\+Vector}$<$ \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type}, 2 $>$ \hyperlink{classnmr_s_v_d_dynamic_data_a3673bb17448a97213388b41ce36ef5b0}{nsize\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classnmr_s_v_d_dynamic_data_a4593ac097bf34c9d47dd5376fff4a1ad}{nmr\+S\+V\+D\+Dynamic\+Data} ()
\item 
\hyperlink{classnmr_s_v_d_dynamic_data_a7421212bc93d5918f8cb0304b86af723}{nmr\+S\+V\+D\+Dynamic\+Data} (\hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} m, \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} n, bool storage\+Order)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\\hyperlink{classnmr_s_v_d_dynamic_data_a30ec8ad8e492d372f738d432812ccb90}{nmr\+S\+V\+D\+Dynamic\+Data} (const \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\\hyperlink{classnmr_s_v_d_dynamic_data_a9e541e82c336fdf328d07906b01332ff}{nmr\+S\+V\+D\+Dynamic\+Data} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Workspace)
\item 
{\footnotesize template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt , typename \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\\hyperlink{classnmr_s_v_d_dynamic_data_a8343a2867cf615e4deb350369e0a29ff}{nmr\+S\+V\+D\+Dynamic\+Data} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+U, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+S, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Vt, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Workspace)
\item 
{\footnotesize template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt $>$ }\\\hyperlink{classnmr_s_v_d_dynamic_data_a366c5378160a8d0a1a4174cd21ae2692}{nmr\+S\+V\+D\+Dynamic\+Data} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+U, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+S, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Vt)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\void \hyperlink{classnmr_s_v_d_dynamic_data_ae1d9a4869e753a1b838b14de75f1308f}{Allocate} (const \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\void \hyperlink{classnmr_s_v_d_dynamic_data_a6940b17dbc208214e9cbecef8c4dd3b9}{Set\+Ref\+Workspace} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Workspace)
\item 
void \hyperlink{classnmr_s_v_d_dynamic_data_aa65dc5751725c24564ea094609152c3b}{Allocate} (\hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} m, \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} n, bool storage\+Order)
\item 
{\footnotesize template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt , typename \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\void \hyperlink{classnmr_s_v_d_dynamic_data_a721078abe670ddb39948e5a234374f05}{Set\+Ref} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+U, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+S, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Vt, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Workspace)  throw (std\+::runtime\+\_\+error)
\item 
{\footnotesize template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt $>$ }\\void \hyperlink{classnmr_s_v_d_dynamic_data_a8099ef202b4802eacd56511fc5c393dd}{Set\+Ref\+Output} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+U, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+S, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Vt)  throw (std\+::runtime\+\_\+error)
\item 
const \hyperlink{classvct_dynamic_vector_ref}{vct\+Dynamic\+Vector\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \& \hyperlink{classnmr_s_v_d_dynamic_data_a9ad290536daf096858e7dc9ecb4665f2}{S} (void) const 
\item 
const \hyperlink{classvct_dynamic_matrix_ref}{vct\+Dynamic\+Matrix\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \& \hyperlink{classnmr_s_v_d_dynamic_data_ad77c3cbe127481ab64a8f8134ee49045}{U} (void) const 
\item 
const \hyperlink{classvct_dynamic_matrix_ref}{vct\+Dynamic\+Matrix\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \& \hyperlink{classnmr_s_v_d_dynamic_data_a611c65dc458f9e976e4b1c52134adfa8}{Vt} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} \hyperlink{classnmr_s_v_d_dynamic_data_a26c2eb67f4481c071e7683998aef3799}{Workspace\+Size} (\hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} m, \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} n)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\static \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} \hyperlink{classnmr_s_v_d_dynamic_data_a9dd6679bb22385b00165277c4e866fb5}{Workspace\+Size} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\static \hyperlink{classnmr_s_v_d_dynamic_data_a3673bb17448a97213388b41ce36ef5b0}{nsize\+\_\+type} \hyperlink{classnmr_s_v_d_dynamic_data_a249bc6db62dbf3336f447f309ac05c7f}{Matrix\+S\+Size} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+matrix\+Owner\+Type\+S , class \+\_\+vector\+Owner\+Type\+S $>$ }\\static \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \& \hyperlink{classnmr_s_v_d_dynamic_data_a293914bccd0068243631c34d38089f94}{Update\+Matrix\+S} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, const \hyperlink{classvct_dynamic_const_vector_base}{vct\+Dynamic\+Const\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&vector\+S, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&matrix\+S)  throw (std\+::runtime\+\_\+error)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classnmr_s_v_d_dynamic_data_a71cf527dd5870e18bab550de89803451}{Set\+Dimension} (\hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} m, \hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} n, bool storage\+Order)
\item 
void \hyperlink{classnmr_s_v_d_dynamic_data_a0b84333242f474836d0ee48b3a678a03}{Allocate\+Output\+Workspace} (bool allocate\+Output, bool allocate\+Workspace)
\item 
{\footnotesize template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt $>$ }\\void \hyperlink{classnmr_s_v_d_dynamic_data_ad977e852969cacde23c5cb5e6460f9a7}{Throw\+Unless\+Output\+Size\+Is\+Correct} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+U, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+S, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Vt) const   throw (std\+::runtime\+\_\+error)
\item 
{\footnotesize template$<$typename \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\void \hyperlink{classnmr_s_v_d_dynamic_data_af81993cfb7844ec8a3528a68f1cac288}{Throw\+Unless\+Workspace\+Size\+Is\+Correct} (\hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&in\+Workspace) const   throw (std\+::runtime\+\_\+error)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_s_v_d_dynamic_data_abe50251589c5f7d24ae6d2024f7344f0}{Workspace\+Memory}
\item 
\hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_s_v_d_dynamic_data_a62cf889a1182a098e665a73f4985a9ba}{Output\+Memory}
\end{DoxyCompactItemize}
{\bf }\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{classvct_dynamic_matrix_ref}{vct\+Dynamic\+Matrix\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_s_v_d_dynamic_data_a2f627a078f4bb1bc05c54f2e3269ae2c}{U\+Reference}
\item 
\hyperlink{classvct_dynamic_matrix_ref}{vct\+Dynamic\+Matrix\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_s_v_d_dynamic_data_a55d8b13fe84f67743291578ce94578b0}{Vt\+Reference}
\item 
\hyperlink{classvct_dynamic_vector_ref}{vct\+Dynamic\+Vector\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_s_v_d_dynamic_data_a695e21e7e405283b5f16b9285c31d5eb}{S\+Reference}
\item 
\hyperlink{classvct_dynamic_vector_ref}{vct\+Dynamic\+Vector\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_s_v_d_dynamic_data_a616c1ec08f23128458db53bbfb1fa0b2}{Workspace\+Reference}
\end{DoxyCompactItemize}

{\bf }\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} \hyperlink{classnmr_s_v_d_dynamic_data_a80e8b2828a7f24b24a6633bf6caa3ad4}{M\+Member}
\item 
\hyperlink{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{size\+\_\+type} \hyperlink{classnmr_s_v_d_dynamic_data_a4096b80ce5ddda1a17c49c4565bf33db}{N\+Member}
\item 
bool \hyperlink{classnmr_s_v_d_dynamic_data_ad8bf7fcd150c906b3f7407b5a91fa51b}{Storage\+Order\+Member}
\end{DoxyCompactItemize}

\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnmr_s_v_d_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}{Friend}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Data for S\+V\+D problem (Dynamic). 

The result of an S\+V\+D decomposition is composed of three different containers, the matrices U and V and the vector S defined by $ A = U * \Sigma * V^{T} $. The sizes of these components must match exactly the input matrix A. To ease the use of the S\+V\+D routine, the user can rely on the \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data} class to perform the required memory allocation. Furthermore, the underlying Fortran routine from L\+A\+P\+A\+C\+K requires a workspace (aka a scratch space). This workspace can also be allocated by the \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data}.

Another good reason to use a \char`\"{}data\char`\"{} object is that the memory allocation can be performed once during an initialization phase while the function nmr\+S\+V\+D can be called numerous times later on without any new dynamic memory allocation. This is crucial for such things as real time tasks.

The S\+V\+D routine is somewhat specific in the sens that is can be used on either storage order, row major or column major, without any copy or transpose. Nevertheless, the current implementation requires all the matrices to use the same storage order, i.\+e. if A is row major, both U and Vt must be stored row first. Matrices and vectors must also be compact, i.\+e. use a contiguous block of memory.

Any size or storage order mismatch will lead to an exception thrown (std\+::runtime\+\_\+error). Since we are using cmn\+Throw, it is possible to configure cisst (at compilation time) to abort the program instead of throwing an exception.

The \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data} class allows 4 different configurations\+:


\begin{DoxyItemize}
\item Allocate automatically everything, i.\+e. the output (U, S and Vt) as well as the workspace. This can be performed using either the constructor from input matrix (i.\+e. \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data(\+A)}) or using the method Allocate(\+A).
\item Automatically allocate the workspace but rely on user allocated U, S and Vt. The size of the problem, i.\+e. the input matrix A as well as the storage order will be deduced from U, S and Vt. This can be performed using either the constructor from U, S and Vt (i.\+e. \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data(\+U, S, Vt)}) or the method Set\+Ref\+Output(\+U, S, Vt).
\item Automatically allocate the output but rely on user allocated workspace. This can be useful if the user decides to create a large workspace for multiple numerical routines. The user will have to make sure his program is thread-\/safe. This can be performed using either the constructor from A and the workspace (i.\+e. \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data(\+A, workspace)}) or the method Set\+Ref\+Workspace(\+A, workspace). Please note that the matrix A is required to compute the dimension of the problem since the only requirement or the workspace is that it must be large enough.
\item Don\textquotesingle{}t allocate anything. The user has to provide the containers he wants to use for U, S, Vt and the workspace. In this case, the \char`\"{}data\char`\"{} is used mostly to check that all the containers are valid in terms of size and storage order. This can be performed using either the constructor from U, S, Vt and workspace (i.\+e. \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data(\+U, S, Vt, workspace)}) or the method Set\+Ref(\+U, S, Vt, workspace).
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
\hyperlink{nmr_s_v_d_8h_a52115d0e7a485c4494aa20f4f3f4ebe7}{nmr\+S\+V\+D} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\hypertarget{classnmr_s_v_d_dynamic_data_a3673bb17448a97213388b41ce36ef5b0}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nsize\+\_\+type@{nsize\+\_\+type}}
\index{nsize\+\_\+type@{nsize\+\_\+type}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{nsize\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf vct\+Fixed\+Size\+Vector}$<${\bf size\+\_\+type}, 2$>$ {\bf nmr\+S\+V\+D\+Dynamic\+Data\+::nsize\+\_\+type}}\label{classnmr_s_v_d_dynamic_data_a3673bb17448a97213388b41ce36ef5b0}
Matrix size type, i.\+e. vector of two elements\+: number of rows and columns. \hypertarget{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!size\+\_\+type@{size\+\_\+type}}
\index{size\+\_\+type@{size\+\_\+type}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{size\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf vct\+::size\+\_\+type} {\bf nmr\+S\+V\+D\+Dynamic\+Data\+::size\+\_\+type}}\label{classnmr_s_v_d_dynamic_data_ae1d183124f1fe39da05af9cea168101d}
Type used for sizes within \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data}. This type is compatible with the cisst\+Vector containers such as \hyperlink{classvct_dynamic_matrix}{vct\+Dynamic\+Matrix} and \hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector} (unsigned int). To call the Fortran based routines, these values must be cast to \#\+C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classnmr_s_v_d_dynamic_data_a4593ac097bf34c9d47dd5376fff4a1ad}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{nmr\+S\+V\+D\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}nmr\+S\+V\+D\+Dynamic\+Data\+::nmr\+S\+V\+D\+Dynamic\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a4593ac097bf34c9d47dd5376fff4a1ad}
The default constuctor. For dynamic size, there are assigned default values, i.\+e. sets all the dimensions to zero. These M\+U\+S\+T be changed by calling the appropriate method.

\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_s_v_d_dynamic_data_ae1d9a4869e753a1b838b14de75f1308f}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Allocate} \hyperlink{classnmr_s_v_d_dynamic_data_a8099ef202b4802eacd56511fc5c393dd}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref\+Output} \hyperlink{classnmr_s_v_d_dynamic_data_a6940b17dbc208214e9cbecef8c4dd3b9}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref\+Workspace} \hyperlink{classnmr_s_v_d_dynamic_data_a721078abe670ddb39948e5a234374f05}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref} 
\end{DoxySeeAlso}
\hypertarget{classnmr_s_v_d_dynamic_data_a7421212bc93d5918f8cb0304b86af723}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{nmr\+S\+V\+D\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}nmr\+S\+V\+D\+Dynamic\+Data\+::nmr\+S\+V\+D\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{m, }
\item[{{\bf size\+\_\+type}}]{n, }
\item[{bool}]{storage\+Order}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a7421212bc93d5918f8cb0304b86af723}
Constructor where the user specifies the size and storage order. Memory allocation is performed for the output matrices and vectors as well as Workspace used by L\+A\+P\+A\+C\+K. This should be used when the user doesn\textquotesingle{}t care much about where the output should be stored and doesn\textquotesingle{}t need to share the workspace between different algorithms.


\begin{DoxyParams}{Parameters}
{\em m,n} & Dimension of the matrix to be decomposed. \\
\hline
{\em storage\+Order} & Storage order used for all matrices.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_s_v_d_dynamic_data_ae1d9a4869e753a1b838b14de75f1308f}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Allocate} 
\end{DoxySeeAlso}
\hypertarget{classnmr_s_v_d_dynamic_data_a30ec8ad8e492d372f738d432812ccb90}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{nmr\+S\+V\+D\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ nmr\+S\+V\+D\+Dynamic\+Data\+::nmr\+S\+V\+D\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a30ec8ad8e492d372f738d432812ccb90}
Constructor where the user provides the input matrix to specify the size and storage order. Memory allocation is performed for the output matrices and vectors as well as Workspace used by L\+A\+P\+A\+C\+K. This should be used when the user doesn\textquotesingle{}t care much about where the output should be stored and doesn\textquotesingle{}t need to share the workspace between different algorithms.


\begin{DoxyParams}{Parameters}
{\em A} & input matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_s_v_d_dynamic_data_ae1d9a4869e753a1b838b14de75f1308f}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Allocate} 
\end{DoxySeeAlso}
\hypertarget{classnmr_s_v_d_dynamic_data_a9e541e82c336fdf328d07906b01332ff}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{nmr\+S\+V\+D\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Workspace $>$ nmr\+S\+V\+D\+Dynamic\+Data\+::nmr\+S\+V\+D\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Workspace}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a9e541e82c336fdf328d07906b01332ff}
Constructor where the user provides the input matrix to specify the size and storage order. Memory allocation is performed for the output matrices and vectors only. This constructor should be used when the user cares wants to avoid allocating different workspaces for different numerical routines. Please note that since multiple routines can share the workspace, these routines must be called in a thread safe manner.


\begin{DoxyParams}{Parameters}
{\em A} & input matrix \\
\hline
{\em in\+Workspace} & workspace\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_s_v_d_dynamic_data_a6940b17dbc208214e9cbecef8c4dd3b9}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref\+Workspace} 
\end{DoxySeeAlso}
\hypertarget{classnmr_s_v_d_dynamic_data_a8343a2867cf615e4deb350369e0a29ff}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{nmr\+S\+V\+D\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt , typename \+\_\+vector\+Owner\+Type\+Workspace $>$ nmr\+S\+V\+D\+Dynamic\+Data\+::nmr\+S\+V\+D\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+U, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+S, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Vt, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Workspace}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a8343a2867cf615e4deb350369e0a29ff}
Constructor where the user provides the matrices U, Vt and vectors S as well as the workspace. The data object now acts as a composite container to hold, pass and manipulate a convenient storage for S\+V\+D algorithm. Checks are made on the validity of the input and its consitency in terms of size ans storage order. Please note that since the workspace and the input are now created by the user, special attention must be given to thread safety issues.


\begin{DoxyParams}{Parameters}
{\em in\+U,in\+S,in\+Vt} & The output matrices and vector \\
\hline
{\em in\+Workspace} & The workspace for L\+A\+P\+A\+C\+K.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_s_v_d_dynamic_data_a721078abe670ddb39948e5a234374f05}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref} 
\end{DoxySeeAlso}
\hypertarget{classnmr_s_v_d_dynamic_data_a366c5378160a8d0a1a4174cd21ae2692}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{nmr\+S\+V\+D\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt $>$ nmr\+S\+V\+D\+Dynamic\+Data\+::nmr\+S\+V\+D\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+U, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+S, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Vt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a366c5378160a8d0a1a4174cd21ae2692}
Constructor where the user provides the matrices U, Vt and vectors S. The workspace will be allocated and managed by the \char`\"{}data\char`\"{}. This constructor should be used when the user already has a storage for the data but doesn\textquotesingle{}t care much about the workspace.


\begin{DoxyParams}{Parameters}
{\em in\+U,in\+S,in\+Vt} & The output matrices and vector\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_s_v_d_dynamic_data_a8099ef202b4802eacd56511fc5c393dd}{nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref\+Output} 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\hypertarget{classnmr_s_v_d_dynamic_data_ae1d9a4869e753a1b838b14de75f1308f}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Allocate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_ae1d9a4869e753a1b838b14de75f1308f}
This method allocates memory for the output matrices and vector as well as the workspace. The input matrix is used only to determine the size of the problem as well as the storage order (i.\+e. \hyperlink{vct_forward_declarations_8h_a45ba752f741240bf765417ebc8130d62}{V\+C\+T\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+O\+R} or \hyperlink{vct_forward_declarations_8h_a432cdf8923afaf82f551450ad4034746}{V\+C\+T\+\_\+\+C\+O\+L\+\_\+\+M\+A\+J\+O\+R}).

This method should be called before the \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data} object is passed on to nmr\+S\+V\+D function.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix for which S\+V\+D needs to be computed, size Mx\+N \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_aa65dc5751725c24564ea094609152c3b}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Allocate}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{m, }
\item[{{\bf size\+\_\+type}}]{n, }
\item[{bool}]{storage\+Order}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_aa65dc5751725c24564ea094609152c3b}
This method allocates the memory for the output matrices and vector as well as the workspace. This method is not meant to be a top-\/level user A\+P\+I, but is used by other overloaded Allocate methods.


\begin{DoxyParams}{Parameters}
{\em m} & Number of rows of input matrix A. \\
\hline
{\em n} & Number of cols of input matrix A. \\
\hline
{\em storage\+Order} & Storage order of input matrix. One of \hyperlink{vct_forward_declarations_8h_a432cdf8923afaf82f551450ad4034746}{V\+C\+T\+\_\+\+C\+O\+L\+\_\+\+M\+A\+J\+O\+R} or \hyperlink{vct_forward_declarations_8h_a45ba752f741240bf765417ebc8130d62}{V\+C\+T\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+O\+R}. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_a0b84333242f474836d0ee48b3a678a03}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Allocate\+Output\+Workspace@{Allocate\+Output\+Workspace}}
\index{Allocate\+Output\+Workspace@{Allocate\+Output\+Workspace}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Allocate\+Output\+Workspace}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Allocate\+Output\+Workspace (
\begin{DoxyParamCaption}
\item[{bool}]{allocate\+Output, }
\item[{bool}]{allocate\+Workspace}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a0b84333242f474836d0ee48b3a678a03}
Private method to allocate memory for the output and the workspace if needed. This method assumes that the dimension m and n as well as the storage order are already set. It is important to use this method in all the methods provided in the user A\+P\+I, even if all the memory is provided by the user since this method will ensure that the \char`\"{}data\char`\"{} (\hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data}) does not keep any memory allocated. This is for the case where a single \char`\"{}data\char`\"{} is used first to allocate everything and, later on, used with user allocated memory (for either the workspace or the output). For example\+: 
\begin{DoxyCode}
\hyperlink{classvct_dynamic_matrix}{vctDynamicMatrix<double>} A(20, 20);
\hyperlink{group__cisst_vector_ga0d25660a2dc6ef9c093f6f6b2804d2d0}{vctRandom}(A, 10, 10);
\hyperlink{classnmr_s_v_d_dynamic_data}{nmrSVDDynamicData} data(A); \textcolor{comment}{// allocate output AND workspace}
\hyperlink{classvct_dynamic_vector}{vctDynamicVector<double>} workspace(
      \hyperlink{classnmr_s_v_d_dynamic_data_a26c2eb67f4481c071e7683998aef3799}{nmrSVDDynamicData::WorkspaceSize}(A));
data.SetRefWorkspace(workspace); \textcolor{comment}{// after all, use my own workspace}
\end{DoxyCode}
 \begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_s_v_d_dynamic_data_a249bc6db62dbf3336f447f309ac05c7f}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Matrix\+S\+Size@{Matrix\+S\+Size}}
\index{Matrix\+S\+Size@{Matrix\+S\+Size}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Matrix\+S\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ static {\bf nsize\+\_\+type} nmr\+S\+V\+D\+Dynamic\+Data\+::\+Matrix\+S\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_s_v_d_dynamic_data_a249bc6db62dbf3336f447f309ac05c7f}
Helper method to compute the size of the matrix S. This method can be used before Update\+Matrix\+S to make sure that the size of S is correct.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be decomposed using \hyperlink{nmr_s_v_d_8h_a52115d0e7a485c4494aa20f4f3f4ebe7}{nmr\+S\+V\+D} (it is used only to determine the sizes). \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_a9ad290536daf096858e7dc9ecb4665f2}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!S@{S}}
\index{S@{S}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{S}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf vct\+Dynamic\+Vector\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$\& nmr\+S\+V\+D\+Dynamic\+Data\+::\+S (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a9ad290536daf096858e7dc9ecb4665f2}
Const reference to the result vector S. This method must be called after the data has been computed by the nmr\+S\+V\+D function. \hypertarget{classnmr_s_v_d_dynamic_data_a71cf527dd5870e18bab550de89803451}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Set\+Dimension@{Set\+Dimension}}
\index{Set\+Dimension@{Set\+Dimension}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Set\+Dimension}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Dimension (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{m, }
\item[{{\bf size\+\_\+type}}]{n, }
\item[{bool}]{storage\+Order}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a71cf527dd5870e18bab550de89803451}
Private method to set the data members M\+Member, N\+Member and Storage\+Order. This method must be called before Allocate\+Output\+Workspace, Throw\+Unless\+Output\+Size\+Is\+Correct or Throw\+Unless\+Workspace\+Size\+Is\+Correct. \hypertarget{classnmr_s_v_d_dynamic_data_a721078abe670ddb39948e5a234374f05}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Set\+Ref@{Set\+Ref}}
\index{Set\+Ref@{Set\+Ref}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Set\+Ref}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt , typename \+\_\+vector\+Owner\+Type\+Workspace $>$ void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+U, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+S, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Vt, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Workspace}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a721078abe670ddb39948e5a234374f05}
This method doesn\textquotesingle{}t allocate any memory as it relies on user provided matrices and vectors for the output as well as the workspace.

The data object now acts as a composite container to hold, pass and manipulate a convenient storage for S\+V\+D algorithm. The method tests that all the containers provided by the user have the correct size, storage order and are compact.


\begin{DoxyParams}{Parameters}
{\em in\+U,in\+S,in\+Vt} & The output matrices and vector. \\
\hline
{\em in\+Workspace} & The workspace. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_a8099ef202b4802eacd56511fc5c393dd}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Set\+Ref\+Output@{Set\+Ref\+Output}}
\index{Set\+Ref\+Output@{Set\+Ref\+Output}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Set\+Ref\+Output}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt $>$ void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref\+Output (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+U, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+S, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Vt}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a8099ef202b4802eacd56511fc5c393dd}
This method allocates the memory for the workspace. The output memory is provided by the user. The method computes the size of the problem based on the user provided output and verifies that the output components (in\+U, in\+S, and in\+Vt) are consistent with respect to their size and storage order.


\begin{DoxyParams}{Parameters}
{\em in\+U,in\+S,in\+Vt} & The output matrices and vector. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_a6940b17dbc208214e9cbecef8c4dd3b9}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Set\+Ref\+Workspace@{Set\+Ref\+Workspace}}
\index{Set\+Ref\+Workspace@{Set\+Ref\+Workspace}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Set\+Ref\+Workspace}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Workspace $>$ void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Set\+Ref\+Workspace (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Workspace}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a6940b17dbc208214e9cbecef8c4dd3b9}
This method allocates the memory for the output matrices and vector and uses the memory provided by user for workspace. The input matrix A is used to determine the size of the problem as well as the storage order.

This method verifies that the workspace provided by the user is large enough and is compact.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix for which S\+V\+D needs to be computed, size Mx\+N. \\
\hline
{\em in\+Workspace} & The vector used for workspace by L\+A\+P\+A\+C\+K. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_ad977e852969cacde23c5cb5e6460f9a7}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Throw\+Unless\+Output\+Size\+Is\+Correct@{Throw\+Unless\+Output\+Size\+Is\+Correct}}
\index{Throw\+Unless\+Output\+Size\+Is\+Correct@{Throw\+Unless\+Output\+Size\+Is\+Correct}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Throw\+Unless\+Output\+Size\+Is\+Correct}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename \+\_\+matrix\+Owner\+Type\+U , typename \+\_\+vector\+Owner\+Type\+S , typename \+\_\+matrix\+Owner\+Type\+Vt $>$ void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Throw\+Unless\+Output\+Size\+Is\+Correct (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+U, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+S, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+Vt, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Vt}
\end{DoxyParamCaption}
) const throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_ad977e852969cacde23c5cb5e6460f9a7}
Verifies that the user provided references for the output match the size of the \char`\"{}data\char`\"{} as set by Set\+Dimension. This method also checks that the storage orders are consistent across the provided matrices and that all containers are compact.

\begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_s_v_d_dynamic_data_af81993cfb7844ec8a3528a68f1cac288}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Throw\+Unless\+Workspace\+Size\+Is\+Correct@{Throw\+Unless\+Workspace\+Size\+Is\+Correct}}
\index{Throw\+Unless\+Workspace\+Size\+Is\+Correct@{Throw\+Unless\+Workspace\+Size\+Is\+Correct}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Throw\+Unless\+Workspace\+Size\+Is\+Correct}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename \+\_\+vector\+Owner\+Type\+Workspace $>$ void nmr\+S\+V\+D\+Dynamic\+Data\+::\+Throw\+Unless\+Workspace\+Size\+Is\+Correct (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+Workspace}
\end{DoxyParamCaption}
) const throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_af81993cfb7844ec8a3528a68f1cac288}
Verifies that the user provided references for the workspace match (or is greated than) the size of the \char`\"{}data\char`\"{} as set by Set\+Dimension. This method also checks that the workspace is compact.

\begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_s_v_d_dynamic_data_ad77c3cbe127481ab64a8f8134ee49045}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!U@{U}}
\index{U@{U}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{U}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf vct\+Dynamic\+Matrix\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$\& nmr\+S\+V\+D\+Dynamic\+Data\+::\+U (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_ad77c3cbe127481ab64a8f8134ee49045}
Const reference to the result matrix U. This method must be called after the data has been computed by the nmr\+S\+V\+D function. \hypertarget{classnmr_s_v_d_dynamic_data_a293914bccd0068243631c34d38089f94}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Update\+Matrix\+S@{Update\+Matrix\+S}}
\index{Update\+Matrix\+S@{Update\+Matrix\+S}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Update\+Matrix\+S}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+matrix\+Owner\+Type\+S , class \+\_\+vector\+Owner\+Type\+S $>$ static {\bf vct\+Dynamic\+Matrix\+Base}$<$\+\_\+matrix\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$\& nmr\+S\+V\+D\+Dynamic\+Data\+::\+Update\+Matrix\+S (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{const {\bf vct\+Dynamic\+Const\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{vector\+S, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+S, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{matrix\+S}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_s_v_d_dynamic_data_a293914bccd0068243631c34d38089f94}
Fill a matrix from the singular values. Sets all the elements to zero and then replace the diagonal by the singular values (provided by vector\+S).


\begin{DoxyParams}{Parameters}
{\em A} & Matrix decomposed using nmr\+S\+V\+D. This is required to check the dimension of matrix\+S. \\
\hline
{\em vector\+S} & Vector of singular values as computed by nmr\+S\+V\+D. \\
\hline
{\em matrix\+S} & Matrix with storage provided by the user. It must have the same size as A. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_a611c65dc458f9e976e4b1c52134adfa8}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Vt@{Vt}}
\index{Vt@{Vt}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Vt}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf vct\+Dynamic\+Matrix\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$\& nmr\+S\+V\+D\+Dynamic\+Data\+::\+Vt (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_s_v_d_dynamic_data_a611c65dc458f9e976e4b1c52134adfa8}
Const reference to the result matrix Vt (V transposed). This method must be called after the data has been computed by the nmr\+S\+V\+D function. \hypertarget{classnmr_s_v_d_dynamic_data_a26c2eb67f4481c071e7683998aef3799}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Workspace\+Size@{Workspace\+Size}}
\index{Workspace\+Size@{Workspace\+Size}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Workspace\+Size}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf size\+\_\+type} nmr\+S\+V\+D\+Dynamic\+Data\+::\+Workspace\+Size (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{m, }
\item[{{\bf size\+\_\+type}}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_s_v_d_dynamic_data_a26c2eb67f4481c071e7683998aef3799}
Helper methods for user to set minimum working space required by L\+A\+P\+A\+C\+K S\+V\+D routine.


\begin{DoxyParams}{Parameters}
{\em m,n} & The size of matrix whose S\+V\+D needs to be computed. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_s_v_d_dynamic_data_a9dd6679bb22385b00165277c4e866fb5}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Workspace\+Size@{Workspace\+Size}}
\index{Workspace\+Size@{Workspace\+Size}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Workspace\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ static {\bf size\+\_\+type} nmr\+S\+V\+D\+Dynamic\+Data\+::\+Workspace\+Size (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{in\+A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_s_v_d_dynamic_data_a9dd6679bb22385b00165277c4e866fb5}
Helper method to determine the minimum working space required by L\+A\+P\+A\+C\+K S\+V\+D routine.


\begin{DoxyParams}{Parameters}
{\em in\+A} & The matrix whose S\+V\+D needs to be computed \\
\hline
\end{DoxyParams}


\subsection{Friends And Related Function Documentation}
\hypertarget{classnmr_s_v_d_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Friend@{Friend}}
\index{Friend@{Friend}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Friend}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Friend}\hspace{0.3cm}{\ttfamily [friend]}}\label{classnmr_s_v_d_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}


\subsection{Member Data Documentation}
\hypertarget{classnmr_s_v_d_dynamic_data_a80e8b2828a7f24b24a6633bf6caa3ad4}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!M\+Member@{M\+Member}}
\index{M\+Member@{M\+Member}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{M\+Member}]{\setlength{\rightskip}{0pt plus 5cm}{\bf size\+\_\+type} nmr\+S\+V\+D\+Dynamic\+Data\+::\+M\+Member\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a80e8b2828a7f24b24a6633bf6caa3ad4}
Just store M, N, and Storage\+Order which are needed to check if A matrix passed to solve method matches the allocated size. \hypertarget{classnmr_s_v_d_dynamic_data_a4096b80ce5ddda1a17c49c4565bf33db}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!N\+Member@{N\+Member}}
\index{N\+Member@{N\+Member}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{N\+Member}]{\setlength{\rightskip}{0pt plus 5cm}{\bf size\+\_\+type} nmr\+S\+V\+D\+Dynamic\+Data\+::\+N\+Member\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a4096b80ce5ddda1a17c49c4565bf33db}
\hypertarget{classnmr_s_v_d_dynamic_data_a62cf889a1182a098e665a73f4985a9ba}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Output\+Memory@{Output\+Memory}}
\index{Output\+Memory@{Output\+Memory}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Output\+Memory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+S\+V\+D\+Dynamic\+Data\+::\+Output\+Memory\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a62cf889a1182a098e665a73f4985a9ba}
Memory allocated for U, Vt Matrices and Vector S if needed. This method allocates a single block of memory for these 3 containers; m x m elements of U followed by n x n elements of Vt followed by min (m, n) elements of S. \hypertarget{classnmr_s_v_d_dynamic_data_a695e21e7e405283b5f16b9285c31d5eb}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!S\+Reference@{S\+Reference}}
\index{S\+Reference@{S\+Reference}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{S\+Reference}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+S\+V\+D\+Dynamic\+Data\+::\+S\+Reference\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a695e21e7e405283b5f16b9285c31d5eb}
\hypertarget{classnmr_s_v_d_dynamic_data_ad8bf7fcd150c906b3f7407b5a91fa51b}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Storage\+Order\+Member@{Storage\+Order\+Member}}
\index{Storage\+Order\+Member@{Storage\+Order\+Member}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Storage\+Order\+Member}]{\setlength{\rightskip}{0pt plus 5cm}bool nmr\+S\+V\+D\+Dynamic\+Data\+::\+Storage\+Order\+Member\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_ad8bf7fcd150c906b3f7407b5a91fa51b}
\hypertarget{classnmr_s_v_d_dynamic_data_a2f627a078f4bb1bc05c54f2e3269ae2c}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!U\+Reference@{U\+Reference}}
\index{U\+Reference@{U\+Reference}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{U\+Reference}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Matrix\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+S\+V\+D\+Dynamic\+Data\+::\+U\+Reference\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a2f627a078f4bb1bc05c54f2e3269ae2c}
References to workspace or return types, these point either to user allocated memory or our memory chunks if needed. \hypertarget{classnmr_s_v_d_dynamic_data_a55d8b13fe84f67743291578ce94578b0}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Vt\+Reference@{Vt\+Reference}}
\index{Vt\+Reference@{Vt\+Reference}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Vt\+Reference}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Matrix\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+S\+V\+D\+Dynamic\+Data\+::\+Vt\+Reference\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a55d8b13fe84f67743291578ce94578b0}
\hypertarget{classnmr_s_v_d_dynamic_data_abe50251589c5f7d24ae6d2024f7344f0}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Workspace\+Memory@{Workspace\+Memory}}
\index{Workspace\+Memory@{Workspace\+Memory}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Workspace\+Memory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+S\+V\+D\+Dynamic\+Data\+::\+Workspace\+Memory\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_abe50251589c5f7d24ae6d2024f7344f0}
Memory allocated for Workspace matrices if needed. \hypertarget{classnmr_s_v_d_dynamic_data_a616c1ec08f23128458db53bbfb1fa0b2}{}\index{nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}!Workspace\+Reference@{Workspace\+Reference}}
\index{Workspace\+Reference@{Workspace\+Reference}!nmr\+S\+V\+D\+Dynamic\+Data@{nmr\+S\+V\+D\+Dynamic\+Data}}
\subsubsection[{Workspace\+Reference}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+S\+V\+D\+Dynamic\+Data\+::\+Workspace\+Reference\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_s_v_d_dynamic_data_a616c1ec08f23128458db53bbfb1fa0b2}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/anton/devel/cisst-\/saw/cisst/cisst\+Numerical/\hyperlink{nmr_s_v_d_8h}{nmr\+S\+V\+D.\+h}\end{DoxyCompactItemize}
