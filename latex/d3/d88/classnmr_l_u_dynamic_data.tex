\hypertarget{classnmr_l_u_dynamic_data}{}\section{nmr\+L\+U\+Dynamic\+Data Class Reference}
\label{classnmr_l_u_dynamic_data}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}


Data of L\+U problem (Dynamic).  




{\ttfamily \#include $<$nmr\+L\+U.\+h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnmr_l_u_dynamic_data_1_1_friend}{Friend}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{namespacevct_a3e2935e13aac4500965e00d30565775b}{vct\+::size\+\_\+type} \hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type}
\item 
typedef \hyperlink{classvct_fixed_size_vector}{vct\+Fixed\+Size\+Vector}$<$ \hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type}, 2 $>$ \hyperlink{classnmr_l_u_dynamic_data_a5b722c87d1d635328893aa3f54ac35a1}{nsize\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classnmr_l_u_dynamic_data_a55c6a2b66f2b135e11c314f64833d26e}{nmr\+L\+U\+Dynamic\+Data} ()
\item 
\hyperlink{classnmr_l_u_dynamic_data_a05053cf47ae4af807c1c5171ecf2563a}{nmr\+L\+U\+Dynamic\+Data} (\hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} m, \hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} n)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\\hyperlink{classnmr_l_u_dynamic_data_a03630a93e229576e73da3f9a959d4d12}{nmr\+L\+U\+Dynamic\+Data} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ }\\\hyperlink{classnmr_l_u_dynamic_data_a2af25399a0b3ca245b54c956e8e96d87}{nmr\+L\+U\+Dynamic\+Data} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&pivot\+Indices)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\void \hyperlink{classnmr_l_u_dynamic_data_ad585ff877ac1bb95fb585c48f1a84f9b}{Allocate} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
void \hyperlink{classnmr_l_u_dynamic_data_aae8d1c2565653772a475222615cae23b}{Allocate} (\hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} m, \hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} n)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ }\\void \hyperlink{classnmr_l_u_dynamic_data_ae456c133f5faeb23177a4a50fbb20eb7}{Set\+Ref} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&pivot\+Indices)  throw (std\+::runtime\+\_\+error)
\item 
const \hyperlink{classvct_dynamic_vector_ref}{vct\+Dynamic\+Vector\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \& \hyperlink{classnmr_l_u_dynamic_data_a97a173a0a54cfc4954dbef98fafda4f1}{Pivot\+Indices} (void) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\static \hyperlink{classnmr_l_u_dynamic_data_a5b722c87d1d635328893aa3f54ac35a1}{nsize\+\_\+type} \hyperlink{classnmr_l_u_dynamic_data_aa375c57067bf23d67ceca0f21af5a97e}{Matrix\+P\+Size} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\static \hyperlink{classnmr_l_u_dynamic_data_a5b722c87d1d635328893aa3f54ac35a1}{nsize\+\_\+type} \hyperlink{classnmr_l_u_dynamic_data_acd1b9a9e749ea0a16d915d58d3a66b9e}{Matrix\+L\+Size} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\static \hyperlink{classnmr_l_u_dynamic_data_a5b722c87d1d635328893aa3f54ac35a1}{nsize\+\_\+type} \hyperlink{classnmr_l_u_dynamic_data_a984c89b52c9455907020f029577a55f5}{Matrix\+U\+Size} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices , class \+\_\+matrix\+Owner\+Type\+P $>$ }\\static \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+P, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \& \hyperlink{classnmr_l_u_dynamic_data_ae8264b9afe51a6dc9062a28e76e76dd8}{Update\+Matrix\+P} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, const \hyperlink{classvct_dynamic_const_vector_base}{vct\+Dynamic\+Const\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&pivot\+Indices, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+P, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&P)  throw (std\+::runtime\+\_\+error)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+matrix\+Owner\+Type\+L , class \+\_\+matrix\+Owner\+Type\+U $>$ }\\static void \hyperlink{classnmr_l_u_dynamic_data_aa443b07fe53b5008e217350c86f4dd35}{Update\+Matrix\+L\+U} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+L, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&L, \hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&U)  throw (std\+::runtime\+\_\+error)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classnmr_l_u_dynamic_data_ae25247c2e585c43ca927686461f2c699}{Set\+Dimension} (\hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} m, \hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} n)
\item 
void \hyperlink{classnmr_l_u_dynamic_data_ae6ca3b268d36249e02ccaea0a5f5c7df}{Allocate\+Output} (bool allocate\+Output)
\item 
{\footnotesize template$<$class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ }\\void \hyperlink{classnmr_l_u_dynamic_data_afca11b4a534d409a919a1dec84052abb}{Throw\+Unless\+Output\+Size\+Is\+Correct} (\hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&pivot\+Indices)  throw (std\+::runtime\+\_\+error)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \hyperlink{classnmr_l_u_dynamic_data_acf9e9d0bb436f0e04c6d6138b1cbd8fd}{Output\+Memory}
\item 
\hyperlink{classvct_dynamic_vector_ref}{vct\+Dynamic\+Vector\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \hyperlink{classnmr_l_u_dynamic_data_a45c056cf29f16a5e97fafee6484a009e}{Pivot\+Indices\+Reference}
\end{DoxyCompactItemize}
{\bf }\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} \hyperlink{classnmr_l_u_dynamic_data_a859065b13cb287c4e0e67be01f9a779b}{M\+Member}
\item 
\hyperlink{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{size\+\_\+type} \hyperlink{classnmr_l_u_dynamic_data_a44878cc0e7c2c01ea964a57d447b64bb}{N\+Member}
\end{DoxyCompactItemize}

\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnmr_l_u_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}{Friend}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Data of L\+U problem (Dynamic). 

The result of an L\+U decomposition is composed of three different containers, the matrices P, L and U defined by $ A = P * L * U$. The sizes of these components must match exactly the input matrix A. To ease the use of the L\+U routine, the user can rely on the \hyperlink{classnmr_l_u_dynamic_data}{nmr\+L\+U\+Dynamic\+Data} class to perform the required memory allocation.

Another good reason to use a data object is that the memory allocation can be performed once during an initialization phase while the function nmr\+L\+U can be called numerous times later on without any new dynamic memory allocation. This is crucial for such things as real time tasks.

The L\+U routine, as most L\+A\+P\+A\+C\+K and F\+O\+R\+T\+R\+A\+N based routines, requires the input to be stored column first. In cisst\+Vector, this implies that all matrices must be created using \hyperlink{vct_forward_declarations_8h_a432cdf8923afaf82f551450ad4034746}{V\+C\+T\+\_\+\+C\+O\+L\+\_\+\+M\+A\+J\+O\+R}. Furthermore, all matrices and vectors must also be compact, i.\+e. use a contiguous block of memory.

Any size or storage order mismatch will lead to an exception thrown (std\+::runtime\+\_\+error). Since we are using cmn\+Throw, it is possible to configure cisst (at compilation time) to abort the program instead of throwing an exception.

The \hyperlink{classnmr_l_u_dynamic_data}{nmr\+L\+U\+Dynamic\+Data} class allows 2 different configurations\+:


\begin{DoxyItemize}
\item Allocate automatically the output (Pivot\+Indices vector). This can be performed using either the constructor from input matrix (i.\+e. \hyperlink{classnmr_l_u_dynamic_data}{nmr\+L\+U\+Dynamic\+Data(\+A)}) or using the method Allocate(\+A).
\item Don\textquotesingle{}t allocate anything. The user has to provide the container he wants to use for the pivot indices. In this case, the data is used mostly to check that the container is valid in terms of size. This can be performed using either the constructor from Pivot\+Indices (i.\+e. \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data(\+A, Pivot\+Indices)}) or the method Set\+Ref(\+A, Pivot\+Indices).
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
\hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\hypertarget{classnmr_l_u_dynamic_data_a5b722c87d1d635328893aa3f54ac35a1}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nsize\+\_\+type@{nsize\+\_\+type}}
\index{nsize\+\_\+type@{nsize\+\_\+type}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{nsize\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf vct\+Fixed\+Size\+Vector}$<${\bf size\+\_\+type}, 2$>$ {\bf nmr\+L\+U\+Dynamic\+Data\+::nsize\+\_\+type}}\label{classnmr_l_u_dynamic_data_a5b722c87d1d635328893aa3f54ac35a1}
\hypertarget{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!size\+\_\+type@{size\+\_\+type}}
\index{size\+\_\+type@{size\+\_\+type}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{size\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf vct\+::size\+\_\+type} {\bf nmr\+L\+U\+Dynamic\+Data\+::size\+\_\+type}}\label{classnmr_l_u_dynamic_data_a63259a289f8f94498b5102ce39722bbe}
Type used for sizes within \hyperlink{classnmr_l_u_dynamic_data}{nmr\+L\+U\+Dynamic\+Data}. This type is compatible with the cisst\+Vector containers such as \hyperlink{classvct_dynamic_matrix}{vct\+Dynamic\+Matrix} and \hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector} (unsigned int). To call the Fortran based routines, these values must be cast to \#\+C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classnmr_l_u_dynamic_data_a55c6a2b66f2b135e11c314f64833d26e}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{nmr\+L\+U\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}nmr\+L\+U\+Dynamic\+Data\+::nmr\+L\+U\+Dynamic\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_a55c6a2b66f2b135e11c314f64833d26e}
The default constuctor. For dynamic size, there are assigned default values, i.\+e. sets all the dimensions to zero. These M\+U\+S\+T be changed by calling the appropriate method.

\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_l_u_dynamic_data_ad585ff877ac1bb95fb585c48f1a84f9b}{nmr\+L\+U\+Dynamic\+Data\+::\+Allocate} \hyperlink{classnmr_l_u_dynamic_data_ae456c133f5faeb23177a4a50fbb20eb7}{nmr\+L\+U\+Dynamic\+Data\+::\+Set\+Ref} 
\end{DoxySeeAlso}
\hypertarget{classnmr_l_u_dynamic_data_a05053cf47ae4af807c1c5171ecf2563a}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{nmr\+L\+U\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}nmr\+L\+U\+Dynamic\+Data\+::nmr\+L\+U\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{m, }
\item[{{\bf size\+\_\+type}}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_a05053cf47ae4af807c1c5171ecf2563a}
Constructor where the user specifies the size. Memory allocation is performed for pivot indices vector. This should be used when the user doesn\textquotesingle{}t care much about where the output should be stored.


\begin{DoxyParams}{Parameters}
{\em m,n} & Dimension of the matrix to be decomposed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_l_u_dynamic_data_ad585ff877ac1bb95fb585c48f1a84f9b}{nmr\+L\+U\+Dynamic\+Data\+::\+Allocate} 
\end{DoxySeeAlso}
\hypertarget{classnmr_l_u_dynamic_data_a03630a93e229576e73da3f9a959d4d12}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{nmr\+L\+U\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ nmr\+L\+U\+Dynamic\+Data\+::nmr\+L\+U\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_a03630a93e229576e73da3f9a959d4d12}
Constructor where the user provides the input matrix to specify the size and storage order. Memory allocation is performed for pivot indices vector. This should be used when the user doesn\textquotesingle{}t care much about where the output should be stored.


\begin{DoxyParams}{Parameters}
{\em A} & input matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_l_u_dynamic_data_ad585ff877ac1bb95fb585c48f1a84f9b}{nmr\+L\+U\+Dynamic\+Data\+::\+Allocate} 
\end{DoxySeeAlso}
\hypertarget{classnmr_l_u_dynamic_data_a2af25399a0b3ca245b54c956e8e96d87}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{nmr\+L\+U\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ nmr\+L\+U\+Dynamic\+Data\+::nmr\+L\+U\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&}]{pivot\+Indices}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_a2af25399a0b3ca245b54c956e8e96d87}
Constructor where the user provides the vector to store the pivot indices. The data object now acts as a composite container to hold, pass and manipulate a convenient storage for L\+U algorithm. Checks are made on the validity of the input and its consitency in terms of size.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be decomposed, used to verify the sizes. \\
\hline
{\em pivot\+Indices} & Vector created by the user to store the output.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_l_u_dynamic_data_ae456c133f5faeb23177a4a50fbb20eb7}{nmr\+L\+U\+Dynamic\+Data\+::\+Set\+Ref} 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\hypertarget{classnmr_l_u_dynamic_data_ad585ff877ac1bb95fb585c48f1a84f9b}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Allocate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ void nmr\+L\+U\+Dynamic\+Data\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_ad585ff877ac1bb95fb585c48f1a84f9b}
This method allocates memory for the output vector (pivot indices). The input matrix is used only to determine the size of the problem.

This method should be called before the \hyperlink{classnmr_l_u_dynamic_data}{nmr\+L\+U\+Dynamic\+Data} object is passed on to nmr\+L\+U function.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix for which L\+U needs to be computed, size Mx\+N \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_l_u_dynamic_data_aae8d1c2565653772a475222615cae23b}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Allocate}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+L\+U\+Dynamic\+Data\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{m, }
\item[{{\bf size\+\_\+type}}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_aae8d1c2565653772a475222615cae23b}
This method allocates the memory for the output (pivot indices). This method is not meant to be a top-\/level user A\+P\+I, but is used by other overloaded Allocate methods.


\begin{DoxyParams}{Parameters}
{\em m} & Number of rows of input matrix A. \\
\hline
{\em n} & Number of cols of input matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_l_u_dynamic_data_ae6ca3b268d36249e02ccaea0a5f5c7df}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Allocate\+Output@{Allocate\+Output}}
\index{Allocate\+Output@{Allocate\+Output}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Allocate\+Output}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+L\+U\+Dynamic\+Data\+::\+Allocate\+Output (
\begin{DoxyParamCaption}
\item[{bool}]{allocate\+Output}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_l_u_dynamic_data_ae6ca3b268d36249e02ccaea0a5f5c7df}
Private method to allocate memory for the output if needed. This method assumes that the dimension m and n as well as the storage order are already set. It is important to use this method in all the methods provided in the user A\+P\+I, even if all the memory is provided by the user since this method will ensure that the data (\hyperlink{classnmr_l_u_dynamic_data}{nmr\+L\+U\+Dynamic\+Data}) does not keep any memory allocated. This is for the case where a single data object is used first to allocate everything and, later on, used with user allocated memory (for the output).

\begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_l_u_dynamic_data_acd1b9a9e749ea0a16d915d58d3a66b9e}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Matrix\+L\+Size@{Matrix\+L\+Size}}
\index{Matrix\+L\+Size@{Matrix\+L\+Size}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Matrix\+L\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ static {\bf nsize\+\_\+type} nmr\+L\+U\+Dynamic\+Data\+::\+Matrix\+L\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_l_u_dynamic_data_acd1b9a9e749ea0a16d915d58d3a66b9e}
Helper method to compute the size of the matrix L. This method can be used before Update\+Matrix\+L\+U to make sure that the size of L is correct.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be decomposed using \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} (it is used only to determine the sizes). \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_l_u_dynamic_data_aa375c57067bf23d67ceca0f21af5a97e}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Matrix\+P\+Size@{Matrix\+P\+Size}}
\index{Matrix\+P\+Size@{Matrix\+P\+Size}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Matrix\+P\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ static {\bf nsize\+\_\+type} nmr\+L\+U\+Dynamic\+Data\+::\+Matrix\+P\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_l_u_dynamic_data_aa375c57067bf23d67ceca0f21af5a97e}
Helper method to compute the size of the permutation matrix. This method can be used before Update\+Matrix\+P to make sure that the size of P is correct.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be decomposed using \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} (it is used only to determine the sizes). \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_l_u_dynamic_data_a984c89b52c9455907020f029577a55f5}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Matrix\+U\+Size@{Matrix\+U\+Size}}
\index{Matrix\+U\+Size@{Matrix\+U\+Size}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Matrix\+U\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ static {\bf nsize\+\_\+type} nmr\+L\+U\+Dynamic\+Data\+::\+Matrix\+U\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_l_u_dynamic_data_a984c89b52c9455907020f029577a55f5}
Helper method to compute the size of the matrix U. This method can be used before Update\+Matrix\+L\+U to make sure that the size of U is correct.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be decomposed using \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} (it is used only to determine the sizes). \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_l_u_dynamic_data_a97a173a0a54cfc4954dbef98fafda4f1}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Pivot\+Indices@{Pivot\+Indices}}
\index{Pivot\+Indices@{Pivot\+Indices}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Pivot\+Indices}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf vct\+Dynamic\+Vector\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R$>$\& nmr\+L\+U\+Dynamic\+Data\+::\+Pivot\+Indices (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_a97a173a0a54cfc4954dbef98fafda4f1}
Const reference to the result vector Pivot\+Indices. This method must be called after the data has been computed by the nmr\+L\+U function. \hypertarget{classnmr_l_u_dynamic_data_ae25247c2e585c43ca927686461f2c699}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Set\+Dimension@{Set\+Dimension}}
\index{Set\+Dimension@{Set\+Dimension}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Set\+Dimension}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+L\+U\+Dynamic\+Data\+::\+Set\+Dimension (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{m, }
\item[{{\bf size\+\_\+type}}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_l_u_dynamic_data_ae25247c2e585c43ca927686461f2c699}
Private method to set the data members M\+Member and N\+Member. This method must be called before Allocate\+Output, Throw\+Unless\+Output\+Size\+Is\+Correct or Throw\+Unless\+Workspace\+Size\+Is\+Correct. \hypertarget{classnmr_l_u_dynamic_data_ae456c133f5faeb23177a4a50fbb20eb7}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Set\+Ref@{Set\+Ref}}
\index{Set\+Ref@{Set\+Ref}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Set\+Ref}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ void nmr\+L\+U\+Dynamic\+Data\+::\+Set\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&}]{pivot\+Indices}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_l_u_dynamic_data_ae456c133f5faeb23177a4a50fbb20eb7}
This method doesn\textquotesingle{}t allocate any memory as it relies on the user provided vector (pivot\+Indices).

The data object now acts as a composite container to hold, pass and manipulate a convenient storage for L\+U algorithm. The method tests that all the containers provided by the user have the correct size and are compact.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be decomposed, used to verify the sizes. \\
\hline
{\em pivot\+Indices} & Vector created by the user to store the output. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_l_u_dynamic_data_afca11b4a534d409a919a1dec84052abb}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Throw\+Unless\+Output\+Size\+Is\+Correct@{Throw\+Unless\+Output\+Size\+Is\+Correct}}
\index{Throw\+Unless\+Output\+Size\+Is\+Correct@{Throw\+Unless\+Output\+Size\+Is\+Correct}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Throw\+Unless\+Output\+Size\+Is\+Correct}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ void nmr\+L\+U\+Dynamic\+Data\+::\+Throw\+Unless\+Output\+Size\+Is\+Correct (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&}]{pivot\+Indices}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_l_u_dynamic_data_afca11b4a534d409a919a1dec84052abb}
Verifies that the user provided references for the output match the size of the data object as set by Set\+Dimension. This method also checks that all containers are compact.

\begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_l_u_dynamic_data_aa443b07fe53b5008e217350c86f4dd35}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Update\+Matrix\+L\+U@{Update\+Matrix\+L\+U}}
\index{Update\+Matrix\+L\+U@{Update\+Matrix\+L\+U}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Update\+Matrix\+L\+U}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+matrix\+Owner\+Type\+L , class \+\_\+matrix\+Owner\+Type\+U $>$ static void nmr\+L\+U\+Dynamic\+Data\+::\+Update\+Matrix\+L\+U (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+L, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{L, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+U, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{U}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_l_u_dynamic_data_aa443b07fe53b5008e217350c86f4dd35}
Helper method to create usable matrix L and U from the input matrix used and modified by \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U}. The output of \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} is a single matrix which contains both L and U. This method splits the output of nmr\+L\+U and creates to matrices by copying the lower and upper parts respectively in L and U, setting all other elements to zero. The diagonal of the output is copied to U while all the elements of the diagonal of L are set to 1.

\begin{DoxyNote}{Note}
This method must be called after the \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} function has been called.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em A} & The matrix decomposed using \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U}. \\
\hline
{\em L} & The lower matrix \\
\hline
{\em U} & The upper matrix \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_l_u_dynamic_data_ae8264b9afe51a6dc9062a28e76e76dd8}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Update\+Matrix\+P@{Update\+Matrix\+P}}
\index{Update\+Matrix\+P@{Update\+Matrix\+P}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Update\+Matrix\+P}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices , class \+\_\+matrix\+Owner\+Type\+P $>$ static {\bf vct\+Dynamic\+Matrix\+Base}$<$\+\_\+matrix\+Owner\+Type\+P, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$\& nmr\+L\+U\+Dynamic\+Data\+::\+Update\+Matrix\+P (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{const {\bf vct\+Dynamic\+Const\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&}]{pivot\+Indices, }
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+P, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{P}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_l_u_dynamic_data_ae8264b9afe51a6dc9062a28e76e76dd8}
Helper method to create a usable permutation matrix from the vector of pivot indices created by \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U}.

\begin{DoxyNote}{Note}
This method must be called after the \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} function has been called.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em A} & The matrix decomposed using \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U}. It is used only to check the sizes. \\
\hline
{\em pivot\+Indices} & The vector of pivot indices as computed by \hyperlink{nmr_l_u_8h_a66bf403c705953a781e940cf1b674d5f}{nmr\+L\+U} \\
\hline
{\em P} & The permutation matrix updated from the pivot indices. \\
\hline
\end{DoxyParams}


\subsection{Friends And Related Function Documentation}
\hypertarget{classnmr_l_u_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Friend@{Friend}}
\index{Friend@{Friend}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Friend}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Friend}\hspace{0.3cm}{\ttfamily [friend]}}\label{classnmr_l_u_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}


\subsection{Member Data Documentation}
\hypertarget{classnmr_l_u_dynamic_data_a859065b13cb287c4e0e67be01f9a779b}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!M\+Member@{M\+Member}}
\index{M\+Member@{M\+Member}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{M\+Member}]{\setlength{\rightskip}{0pt plus 5cm}{\bf size\+\_\+type} nmr\+L\+U\+Dynamic\+Data\+::\+M\+Member\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_l_u_dynamic_data_a859065b13cb287c4e0e67be01f9a779b}
Just store M, and N which are needed to check if A matrix passed to solve method matches the allocated size. \hypertarget{classnmr_l_u_dynamic_data_a44878cc0e7c2c01ea964a57d447b64bb}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!N\+Member@{N\+Member}}
\index{N\+Member@{N\+Member}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{N\+Member}]{\setlength{\rightskip}{0pt plus 5cm}{\bf size\+\_\+type} nmr\+L\+U\+Dynamic\+Data\+::\+N\+Member\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_l_u_dynamic_data_a44878cc0e7c2c01ea964a57d447b64bb}
\hypertarget{classnmr_l_u_dynamic_data_acf9e9d0bb436f0e04c6d6138b1cbd8fd}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Output\+Memory@{Output\+Memory}}
\index{Output\+Memory@{Output\+Memory}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Output\+Memory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R$>$ nmr\+L\+U\+Dynamic\+Data\+::\+Output\+Memory\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_l_u_dynamic_data_acf9e9d0bb436f0e04c6d6138b1cbd8fd}
Memory allocated for pivot indices vector if needed. \hypertarget{classnmr_l_u_dynamic_data_a45c056cf29f16a5e97fafee6484a009e}{}\index{nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}!Pivot\+Indices\+Reference@{Pivot\+Indices\+Reference}}
\index{Pivot\+Indices\+Reference@{Pivot\+Indices\+Reference}!nmr\+L\+U\+Dynamic\+Data@{nmr\+L\+U\+Dynamic\+Data}}
\subsubsection[{Pivot\+Indices\+Reference}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R$>$ nmr\+L\+U\+Dynamic\+Data\+::\+Pivot\+Indices\+Reference\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_l_u_dynamic_data_a45c056cf29f16a5e97fafee6484a009e}
Reference return type, this points either to user allocated memory or our memory chunk if needed. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/anton/devel/cisst-\/saw/cisst/cisst\+Numerical/\hyperlink{nmr_l_u_8h}{nmr\+L\+U.\+h}\end{DoxyCompactItemize}
