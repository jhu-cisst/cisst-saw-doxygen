\hypertarget{classnmr_inverse_dynamic_data}{}\section{nmr\+Inverse\+Dynamic\+Data Class Reference}
\label{classnmr_inverse_dynamic_data}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}


Data for Inverse problem (Dynamic).  




{\ttfamily \#include $<$nmr\+Inverse.\+h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnmr_inverse_dynamic_data_1_1_friend}{Friend}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \{ \hyperlink{group__cisst_numerical_ggad99b8f3eaeb516bd937224b0209b27f0a7aa4b91bbfeaafff839f5290659f8067}{N\+B} = 64
 \}
\item 
typedef \hyperlink{namespacevct_a3e2935e13aac4500965e00d30565775b}{vct\+::size\+\_\+type} \hyperlink{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{size\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classnmr_inverse_dynamic_data_a6f3268822254ce8a93f001c4db50ca1c}{nmr\+Inverse\+Dynamic\+Data} ()
\item 
\hyperlink{classnmr_inverse_dynamic_data_a45dde6cb419f11c6c5cec71d38f0c08d}{nmr\+Inverse\+Dynamic\+Data} (\hyperlink{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{size\+\_\+type} size, bool storage\+Order)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\\hyperlink{classnmr_inverse_dynamic_data_a0ba22ece629f3a025f4dfd721dfa54f0}{nmr\+Inverse\+Dynamic\+Data} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices , class \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\\hyperlink{classnmr_inverse_dynamic_data_a6c0cdafd73bb3bad4b7f6113577044c4}{nmr\+Inverse\+Dynamic\+Data} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&pivot\+Indices, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&workspace)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\void \hyperlink{classnmr_inverse_dynamic_data_af35278f260546fa717a23a0950e6a4d9}{Allocate} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
void \hyperlink{classnmr_inverse_dynamic_data_a27ddc2327775aeb06396961e06c92f7d}{Allocate} (\hyperlink{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{size\+\_\+type} size, bool storage\+Order)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices , class \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\void \hyperlink{classnmr_inverse_dynamic_data_a63ba1f6ac432d51a55e029277fb025ed}{Set\+Ref} (\hyperlink{classvct_dynamic_matrix_base}{vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&pivot\+Indices, \hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&workspace)  throw (std\+::runtime\+\_\+error)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\static \hyperlink{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{size\+\_\+type} \hyperlink{classnmr_inverse_dynamic_data_ab327168662ab28ad8ae94e3b08acb7e7}{Pivot\+Indices\+Size} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\item 
{\footnotesize template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ }\\static \hyperlink{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{size\+\_\+type} \hyperlink{classnmr_inverse_dynamic_data_ae35f9f1621272764b8e2b057410a9eeb}{Workspace\+Size} (const \hyperlink{classvct_dynamic_const_matrix_base}{vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&A)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classnmr_inverse_dynamic_data_a054d4de772b71ab8da045f070f00aa1a}{Set\+Dimension} (\hyperlink{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{size\+\_\+type} size, bool storage\+Order)
\item 
void \hyperlink{classnmr_inverse_dynamic_data_accb38be41c1792e06d5d97748990682c}{Allocate\+Pivot\+Indices\+Workspace} (bool allocate\+Pivot\+Indices, bool allocate\+Workspace)
\item 
{\footnotesize template$<$class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ }\\void \hyperlink{classnmr_inverse_dynamic_data_a25f183e2ef43867ea19f98422818abb5}{Throw\+Unless\+Pivot\+Indices\+Size\+Is\+Correct} (\hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&pivot\+Indices)  throw (std\+::runtime\+\_\+error)
\item 
{\footnotesize template$<$class \+\_\+vector\+Owner\+Type\+Workspace $>$ }\\void \hyperlink{classnmr_inverse_dynamic_data_ae330256d35b7e69cb5e39532b92365ed}{Throw\+Unless\+Workspace\+Size\+Is\+Correct} (\hyperlink{classvct_dynamic_vector_base}{vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&workspace)  throw (std\+::runtime\+\_\+error)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \hyperlink{classnmr_inverse_dynamic_data_a011a6d0e52a20011ac77ac48ea65dc1b}{Pivot\+Indices\+Memory}
\item 
\hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_inverse_dynamic_data_ae76c0f077fd60cafab907d5f0e20a490}{Workspace\+Memory}
\end{DoxyCompactItemize}
{\bf }\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{classvct_dynamic_vector_ref}{vct\+Dynamic\+Vector\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \hyperlink{classnmr_inverse_dynamic_data_ad6e68ee1c9a9705d80c5b8e69c2ec34d}{Pivot\+Indices\+Reference}
\item 
\hyperlink{classvct_dynamic_vector_ref}{vct\+Dynamic\+Vector\+Ref}$<$ C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \hyperlink{classnmr_inverse_dynamic_data_a5233a5419f7da87a54abd486832b0817}{Workspace\+Reference}
\end{DoxyCompactItemize}

{\bf }\par
\begin{DoxyCompactItemize}
\item 
\hyperlink{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{size\+\_\+type} \hyperlink{classnmr_inverse_dynamic_data_ae4b1064f9e37250025710add092a33cf}{Size\+Member}
\item 
bool \hyperlink{classnmr_inverse_dynamic_data_a295f57a6eaeca3374aa4e58e983ccefd}{Storage\+Order\+Member}
\end{DoxyCompactItemize}

\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnmr_inverse_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}{Friend}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Data for Inverse problem (Dynamic). 

To ease the use of the Inverse routine, the user can rely on the \hyperlink{classnmr_inverse_dynamic_data}{nmr\+Inverse\+Dynamic\+Data} class to perform the required memory allocation.

Another good reason to use a data object is that the memory allocation can be performed once during an initialization phase while the function nmr\+Inverse can be called numerous times later on without any new dynamic memory allocation. This is crucial for such things as real time tasks.

The Inverse routine can be used for different storage orders, i.\+e. either \hyperlink{vct_forward_declarations_8h_a45ba752f741240bf765417ebc8130d62}{V\+C\+T\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+O\+R} or \hyperlink{vct_forward_declarations_8h_a432cdf8923afaf82f551450ad4034746}{V\+C\+T\+\_\+\+C\+O\+L\+\_\+\+M\+A\+J\+O\+R}. The only restriction is that all matrices and vectors must also be compact, i.\+e. use a contiguous block of memory.

Any size or storage order mismatch will lead to an exception thrown (std\+::runtime\+\_\+error). Since we are using cmn\+Throw, it is possible to configure cisst (at compilation time) to abort the program instead of throwing an exception.

The \hyperlink{classnmr_inverse_dynamic_data}{nmr\+Inverse\+Dynamic\+Data} class allows 2 different configurations\+:


\begin{DoxyItemize}
\item Allocate automatically the workspace (Pivot\+Indices vector and Workspace). This can be performed using either the constructor from input matrix (i.\+e. \hyperlink{classnmr_inverse_dynamic_data}{nmr\+Inverse\+Dynamic\+Data(\+A)}) or using the method Allocate(\+A).
\item Don\textquotesingle{}t allocate anything. The user has to provide the container he wants to use for the workspace and the vector of pivot indices. In this case, the data is used mostly to check that the container is valid in terms of size. This can be performed using either the constructor from Pivot\+Indices (i.\+e. \hyperlink{classnmr_s_v_d_dynamic_data}{nmr\+S\+V\+D\+Dynamic\+Data}(A, pivot\+Indices, workspace)) or the method Set\+Ref(A, pivot\+Indices, workspace).
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
\hyperlink{nmr_inverse_8h_a018d876444a46377abdd85e296643035}{nmr\+Inverse} 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\hypertarget{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!size\+\_\+type@{size\+\_\+type}}
\index{size\+\_\+type@{size\+\_\+type}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{size\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf vct\+::size\+\_\+type} {\bf nmr\+Inverse\+Dynamic\+Data\+::size\+\_\+type}}\label{classnmr_inverse_dynamic_data_aeb5c2317adf50d8fc7952a9b38bf0129}
Type used for sizes within \hyperlink{classnmr_inverse_dynamic_data}{nmr\+Inverse\+Dynamic\+Data}. This type is compatible with the cisst\+Vector containers such as \hyperlink{classvct_dynamic_matrix}{vct\+Dynamic\+Matrix} and \hyperlink{classvct_dynamic_vector}{vct\+Dynamic\+Vector} (unsigned int). To call the Fortran based routines, these values must be cast to C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classnmr_inverse_dynamic_data_a6f3268822254ce8a93f001c4db50ca1c}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{nmr\+Inverse\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}nmr\+Inverse\+Dynamic\+Data\+::nmr\+Inverse\+Dynamic\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_inverse_dynamic_data_a6f3268822254ce8a93f001c4db50ca1c}
The default constuctor. For dynamic size, there are assigned default values, i.\+e. sets all the dimensions to zero. These M\+U\+S\+T be changed by calling the appropriate method.

\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_inverse_dynamic_data_af35278f260546fa717a23a0950e6a4d9}{nmr\+Inverse\+Dynamic\+Data\+::\+Allocate} \hyperlink{classnmr_inverse_dynamic_data_a63ba1f6ac432d51a55e029277fb025ed}{nmr\+Inverse\+Dynamic\+Data\+::\+Set\+Ref} 
\end{DoxySeeAlso}
\hypertarget{classnmr_inverse_dynamic_data_a45dde6cb419f11c6c5cec71d38f0c08d}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{nmr\+Inverse\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}nmr\+Inverse\+Dynamic\+Data\+::nmr\+Inverse\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{size, }
\item[{bool}]{storage\+Order}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_inverse_dynamic_data_a45dde6cb419f11c6c5cec71d38f0c08d}
Constructor where the user specifies the size. Memory allocation is performed for pivot indices vector and workspace. This should be used when the user doesn\textquotesingle{}t care much about where the memory management.


\begin{DoxyParams}{Parameters}
{\em size} & Dimension of the square matrix. \\
\hline
{\em storage\+Order} & Storage order of the matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_inverse_dynamic_data_af35278f260546fa717a23a0950e6a4d9}{nmr\+Inverse\+Dynamic\+Data\+::\+Allocate} 
\end{DoxySeeAlso}
\hypertarget{classnmr_inverse_dynamic_data_a0ba22ece629f3a025f4dfd721dfa54f0}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{nmr\+Inverse\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ nmr\+Inverse\+Dynamic\+Data\+::nmr\+Inverse\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_inverse_dynamic_data_a0ba22ece629f3a025f4dfd721dfa54f0}
Constructor where the user provides the input matrix to specify the size and storage order. Memory allocation is performed for pivot indices vector and workspace. This should be used when the user doesn\textquotesingle{}t care much about memory management.


\begin{DoxyParams}{Parameters}
{\em A} & input matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_inverse_dynamic_data_af35278f260546fa717a23a0950e6a4d9}{nmr\+Inverse\+Dynamic\+Data\+::\+Allocate} 
\end{DoxySeeAlso}
\hypertarget{classnmr_inverse_dynamic_data_a6c0cdafd73bb3bad4b7f6113577044c4}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{nmr\+Inverse\+Dynamic\+Data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices , class \+\_\+vector\+Owner\+Type\+Workspace $>$ nmr\+Inverse\+Dynamic\+Data\+::nmr\+Inverse\+Dynamic\+Data (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&}]{pivot\+Indices, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{workspace}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_inverse_dynamic_data_a6c0cdafd73bb3bad4b7f6113577044c4}
Constructor where the user provides the vector to store the pivot indices and the workspace. The data object now acts as a composite container to hold, pass and manipulate a convenient storage for \hyperlink{nmr_inverse_8h_a018d876444a46377abdd85e296643035}{nmr\+Inverse} algorithm. Checks are made on the validity of the input and its consitency in terms of size.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be inversed, used to verify the sizes. \\
\hline
{\em pivot\+Indices} & Vector created by the user to store the pivot indices. \\
\hline
{\em workspace} & Vector created by the user for the workspace.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classnmr_inverse_dynamic_data_a63ba1f6ac432d51a55e029277fb025ed}{nmr\+Inverse\+Dynamic\+Data\+::\+Set\+Ref} 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\hypertarget{classnmr_inverse_dynamic_data_af35278f260546fa717a23a0950e6a4d9}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Allocate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ void nmr\+Inverse\+Dynamic\+Data\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_inverse_dynamic_data_af35278f260546fa717a23a0950e6a4d9}
This method allocates memory for the pivot indices vector and the workspace. The input matrix is used only to determine the size of these vectors.

This method should be called before the \hyperlink{classnmr_inverse_dynamic_data}{nmr\+Inverse\+Dynamic\+Data} object is passed on to the \hyperlink{nmr_inverse_8h_a018d876444a46377abdd85e296643035}{nmr\+Inverse} function.


\begin{DoxyParams}{Parameters}
{\em A} & The square matrix for which inverse needs to be computed. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_inverse_dynamic_data_a27ddc2327775aeb06396961e06c92f7d}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Allocate}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+Inverse\+Dynamic\+Data\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{size, }
\item[{bool}]{storage\+Order}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_inverse_dynamic_data_a27ddc2327775aeb06396961e06c92f7d}
This method allocates the memory for the pivot indices and the workspace. This method is not meant to be a top-\/level user A\+P\+I, but is used by other overloaded Allocate methods.


\begin{DoxyParams}{Parameters}
{\em size} & Size of the square input matrix A. \\
\hline
{\em storage\+Order} & Storage order of the input matrix. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_inverse_dynamic_data_accb38be41c1792e06d5d97748990682c}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Allocate\+Pivot\+Indices\+Workspace@{Allocate\+Pivot\+Indices\+Workspace}}
\index{Allocate\+Pivot\+Indices\+Workspace@{Allocate\+Pivot\+Indices\+Workspace}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Allocate\+Pivot\+Indices\+Workspace}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+Inverse\+Dynamic\+Data\+::\+Allocate\+Pivot\+Indices\+Workspace (
\begin{DoxyParamCaption}
\item[{bool}]{allocate\+Pivot\+Indices, }
\item[{bool}]{allocate\+Workspace}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_accb38be41c1792e06d5d97748990682c}
Private method to allocate memory for the the pivot indices and the workspace if needed. This method assumes that the dimension m and n as well as the storage order are already set. It is important to use this method in all the methods provided in the user A\+P\+I, even if all the memory is provided by the user since this method will ensure that the data (\hyperlink{classnmr_inverse_dynamic_data}{nmr\+Inverse\+Dynamic\+Data}) does not keep any memory allocated. This is for the case where a single data object is used first to allocate everything and, later on, used with user allocated memory (for the output).

\begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_inverse_dynamic_data_ab327168662ab28ad8ae94e3b08acb7e7}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Pivot\+Indices\+Size@{Pivot\+Indices\+Size}}
\index{Pivot\+Indices\+Size@{Pivot\+Indices\+Size}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Pivot\+Indices\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ static {\bf size\+\_\+type} nmr\+Inverse\+Dynamic\+Data\+::\+Pivot\+Indices\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_inverse_dynamic_data_ab327168662ab28ad8ae94e3b08acb7e7}
Helper method to compute the size of the pivot indices vector.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be used by \hyperlink{nmr_inverse_8h_a018d876444a46377abdd85e296643035}{nmr\+Inverse} (it is used only to determine the size). \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_inverse_dynamic_data_a054d4de772b71ab8da045f070f00aa1a}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Set\+Dimension@{Set\+Dimension}}
\index{Set\+Dimension@{Set\+Dimension}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Set\+Dimension}]{\setlength{\rightskip}{0pt plus 5cm}void nmr\+Inverse\+Dynamic\+Data\+::\+Set\+Dimension (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{size, }
\item[{bool}]{storage\+Order}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_a054d4de772b71ab8da045f070f00aa1a}
Private method to set the data members Size\+Member and Storage\+Order\+Member. This method must be called before Allocate\+Pivot\+Indices\+Workspace, Throw\+Unless\+Output\+Size\+Is\+Correct or Throw\+Unless\+Workspace\+Size\+Is\+Correct. \hypertarget{classnmr_inverse_dynamic_data_a63ba1f6ac432d51a55e029277fb025ed}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Set\+Ref@{Set\+Ref}}
\index{Set\+Ref@{Set\+Ref}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Set\+Ref}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A , class \+\_\+vector\+Owner\+Type\+Pivot\+Indices , class \+\_\+vector\+Owner\+Type\+Workspace $>$ void nmr\+Inverse\+Dynamic\+Data\+::\+Set\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&}]{pivot\+Indices, }
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{workspace}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}}\label{classnmr_inverse_dynamic_data_a63ba1f6ac432d51a55e029277fb025ed}
This method doesn\textquotesingle{}t allocate any memory as it relies on the user provided vectors (pivot\+Indices and workspace).

The data object now acts as a composite container to hold, pass and manipulate a convenient storage for Inverse algorithm. The method tests that all the containers provided by the user have the correct size and are compact.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be inversed, used to verify the sizes. \\
\hline
{\em pivot\+Indices} & Vector created by the user to store the pivot indices. \\
\hline
{\em workspace} & Vector created by the user for the workspace. \\
\hline
\end{DoxyParams}
\hypertarget{classnmr_inverse_dynamic_data_a25f183e2ef43867ea19f98422818abb5}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Throw\+Unless\+Pivot\+Indices\+Size\+Is\+Correct@{Throw\+Unless\+Pivot\+Indices\+Size\+Is\+Correct}}
\index{Throw\+Unless\+Pivot\+Indices\+Size\+Is\+Correct@{Throw\+Unless\+Pivot\+Indices\+Size\+Is\+Correct}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Throw\+Unless\+Pivot\+Indices\+Size\+Is\+Correct}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+vector\+Owner\+Type\+Pivot\+Indices $>$ void nmr\+Inverse\+Dynamic\+Data\+::\+Throw\+Unless\+Pivot\+Indices\+Size\+Is\+Correct (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Pivot\+Indices, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R $>$ \&}]{pivot\+Indices}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_a25f183e2ef43867ea19f98422818abb5}
Verifies that the user provided reference for the pivot indices match the size of the data object as set by Set\+Dimension. This method also checks that all containers are compact.

\begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_inverse_dynamic_data_ae330256d35b7e69cb5e39532b92365ed}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Throw\+Unless\+Workspace\+Size\+Is\+Correct@{Throw\+Unless\+Workspace\+Size\+Is\+Correct}}
\index{Throw\+Unless\+Workspace\+Size\+Is\+Correct@{Throw\+Unless\+Workspace\+Size\+Is\+Correct}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Throw\+Unless\+Workspace\+Size\+Is\+Correct}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+vector\+Owner\+Type\+Workspace $>$ void nmr\+Inverse\+Dynamic\+Data\+::\+Throw\+Unless\+Workspace\+Size\+Is\+Correct (
\begin{DoxyParamCaption}
\item[{{\bf vct\+Dynamic\+Vector\+Base}$<$ \+\_\+vector\+Owner\+Type\+Workspace, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{workspace}
\end{DoxyParamCaption}
) throw  std\+::runtime\+\_\+error) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_ae330256d35b7e69cb5e39532b92365ed}
Verifies that the user provided reference for the workspace match the size of the data object as set by Set\+Dimension. This method also checks that all containers are compact.

\begin{DoxyNote}{Note}
The method Set\+Dimension must have been called before. 
\end{DoxyNote}
\hypertarget{classnmr_inverse_dynamic_data_ae35f9f1621272764b8e2b057410a9eeb}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Workspace\+Size@{Workspace\+Size}}
\index{Workspace\+Size@{Workspace\+Size}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Workspace\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class \+\_\+matrix\+Owner\+Type\+A $>$ static {\bf size\+\_\+type} nmr\+Inverse\+Dynamic\+Data\+::\+Workspace\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf vct\+Dynamic\+Const\+Matrix\+Base}$<$ \+\_\+matrix\+Owner\+Type\+A, C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E $>$ \&}]{A}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classnmr_inverse_dynamic_data_ae35f9f1621272764b8e2b057410a9eeb}
Helper method to compute the size of the workspace vector.


\begin{DoxyParams}{Parameters}
{\em A} & The matrix to be used by \hyperlink{nmr_inverse_8h_a018d876444a46377abdd85e296643035}{nmr\+Inverse} (it is used only to determine the size). \\
\hline
\end{DoxyParams}


\subsection{Friends And Related Function Documentation}
\hypertarget{classnmr_inverse_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Friend@{Friend}}
\index{Friend@{Friend}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Friend}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Friend}\hspace{0.3cm}{\ttfamily [friend]}}\label{classnmr_inverse_dynamic_data_a7f8321d57e81bc613d5dbef3410ba70e}


\subsection{Member Data Documentation}
\hypertarget{classnmr_inverse_dynamic_data_a011a6d0e52a20011ac77ac48ea65dc1b}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Pivot\+Indices\+Memory@{Pivot\+Indices\+Memory}}
\index{Pivot\+Indices\+Memory@{Pivot\+Indices\+Memory}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Pivot\+Indices\+Memory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R$>$ nmr\+Inverse\+Dynamic\+Data\+::\+Pivot\+Indices\+Memory\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_a011a6d0e52a20011ac77ac48ea65dc1b}
Memory allocated for pivot indices vector if needed. \hypertarget{classnmr_inverse_dynamic_data_ad6e68ee1c9a9705d80c5b8e69c2ec34d}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Pivot\+Indices\+Reference@{Pivot\+Indices\+Reference}}
\index{Pivot\+Indices\+Reference@{Pivot\+Indices\+Reference}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Pivot\+Indices\+Reference}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+I\+N\+T\+E\+G\+E\+R$>$ nmr\+Inverse\+Dynamic\+Data\+::\+Pivot\+Indices\+Reference\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_ad6e68ee1c9a9705d80c5b8e69c2ec34d}
Reference return type, this points either to user allocated memory or our memory chunk if needed. \hypertarget{classnmr_inverse_dynamic_data_ae4b1064f9e37250025710add092a33cf}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Size\+Member@{Size\+Member}}
\index{Size\+Member@{Size\+Member}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Size\+Member}]{\setlength{\rightskip}{0pt plus 5cm}{\bf size\+\_\+type} nmr\+Inverse\+Dynamic\+Data\+::\+Size\+Member\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_ae4b1064f9e37250025710add092a33cf}
Store Size and Storage\+Order which are needed to check if A matrix passed \hyperlink{nmr_inverse_8h_a018d876444a46377abdd85e296643035}{nmr\+Inverse} matches the allocated size. \hypertarget{classnmr_inverse_dynamic_data_a295f57a6eaeca3374aa4e58e983ccefd}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Storage\+Order\+Member@{Storage\+Order\+Member}}
\index{Storage\+Order\+Member@{Storage\+Order\+Member}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Storage\+Order\+Member}]{\setlength{\rightskip}{0pt plus 5cm}bool nmr\+Inverse\+Dynamic\+Data\+::\+Storage\+Order\+Member\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_a295f57a6eaeca3374aa4e58e983ccefd}
\hypertarget{classnmr_inverse_dynamic_data_ae76c0f077fd60cafab907d5f0e20a490}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Workspace\+Memory@{Workspace\+Memory}}
\index{Workspace\+Memory@{Workspace\+Memory}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Workspace\+Memory}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+Inverse\+Dynamic\+Data\+::\+Workspace\+Memory\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_ae76c0f077fd60cafab907d5f0e20a490}
Memory allocated for the workspace if needed. \hypertarget{classnmr_inverse_dynamic_data_a5233a5419f7da87a54abd486832b0817}{}\index{nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}!Workspace\+Reference@{Workspace\+Reference}}
\index{Workspace\+Reference@{Workspace\+Reference}!nmr\+Inverse\+Dynamic\+Data@{nmr\+Inverse\+Dynamic\+Data}}
\subsubsection[{Workspace\+Reference}]{\setlength{\rightskip}{0pt plus 5cm}{\bf vct\+Dynamic\+Vector\+Ref}$<$C\+I\+S\+S\+T\+N\+E\+T\+L\+I\+B\+\_\+\+D\+O\+U\+B\+L\+E$>$ nmr\+Inverse\+Dynamic\+Data\+::\+Workspace\+Reference\hspace{0.3cm}{\ttfamily [protected]}}\label{classnmr_inverse_dynamic_data_a5233a5419f7da87a54abd486832b0817}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/anton/devel/cisst-\/saw/cisst/cisst\+Numerical/\hyperlink{nmr_inverse_8h}{nmr\+Inverse.\+h}\end{DoxyCompactItemize}
