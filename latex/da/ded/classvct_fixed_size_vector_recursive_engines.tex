\hypertarget{classvct_fixed_size_vector_recursive_engines}{}\section{vct\+Fixed\+Size\+Vector\+Recursive\+Engines$<$ \+\_\+size $>$ Class Template Reference}
\label{classvct_fixed_size_vector_recursive_engines}\index{vct\+Fixed\+Size\+Vector\+Recursive\+Engines$<$ \+\_\+size $>$@{vct\+Fixed\+Size\+Vector\+Recursive\+Engines$<$ \+\_\+size $>$}}


Container class for the recursive engines.  




{\ttfamily \#include $<$vct\+Fixed\+Size\+Vector\+Recursive\+Engines.\+h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_find}{Find}
\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_min_and_max}{Min\+And\+Max}
\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_select_by_index}{Select\+By\+Index}
\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_so_vi}{So\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $s_o = op_{incr}(op(v_i))$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_so_vi_si}{So\+Vi\+Si}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $s_o = op_{incr}(op(v_i, s_i))$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_so_vi_vi}{So\+Vi\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $s_o = op_{incr}(op(v_{i1}, v_{i2}))$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_so_vo_si}{So\+Vo\+Si}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $s_o = op_{incr}(op(v_o, s_i)$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio}{Vio}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $v_{io} = op(v_{io})$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_si}{Vio\+Si}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $ v_{io} = op(v_{io}, s_i)$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_si_vi}{Vio\+Si\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $v_{io} = op_{io}(v_{io}, op_{sv}(s, v_i))$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_vi}{Vio\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $v_{io} = op(v_{io}, v_i)$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_vio}{Vio\+Vio}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $(v_{1}, v_{2}) = op(v_{1}, v_{2})$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_vi_vi}{Vio\+Vi\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $v_{io} = op_{io}(v_{io}, op_{vv}(v_{i1}, v_{i2}))$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_si_vi}{Vo\+Si\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $v_o = op(s_i, v_i)$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_vi}{Vo\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $v_o = op(v_i)$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_vi_si}{Vo\+Vi\+Si}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $vo = op(vi, si)$ for fixed size vectors. \end{DoxyCompactList}\item 
class \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_vi_vi}{Vo\+Vi\+Vi}
\begin{DoxyCompactList}\small\item\em Implement operation of the form $v_o = op(v_{i1}, v_{i2})$ for fixed size vectors. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$vct\+::size\+\_\+type \+\_\+size$>$class vct\+Fixed\+Size\+Vector\+Recursive\+Engines$<$ \+\_\+size $>$}

Container class for the recursive engines. 

Recursive engines can be used for fixed size vectors (see \hyperlink{classvct_fixed_size_vector}{vct\+Fixed\+Size\+Vector}) to apply similar operations (see \hyperlink{classvct_binary_operations}{vct\+Binary\+Operations}, \hyperlink{classvct_unary_operations}{vct\+Unary\+Operations}, \hyperlink{classvct_store_back_binary_operations}{vct\+Store\+Back\+Binary\+Operations}, \hyperlink{classvct_store_back_unary_operations}{vct\+Store\+Back\+Unary\+Operations}). Each engine corresponds to an operation signature.

Recursive engines are named according to the type of the parameters and their role (i.\+e. input/output). The order reflects the mathematical expression. For exemple, \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_vi_vi}{Vo\+Vi\+Vi} stands for one output vector with two input vectors used in $v_o = v_i op v_i$ and \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_si}{Vio\+Si} stands for one input/output vector and one scalar input used in $v_{io} = v_{io} op s_i$.

The implementation is based on recursive templates which means that the recursion is not translated into recursive calls in an executable but the compilers \char`\"{}unfold\char`\"{} the code during the compilation. The templated format used here was somewhat imposed by the different compilers supported in cisst. Mainly, Visual C++ 6 doesn\textquotesingle{}t support partial specialization. Therefore, the size parameter has to be sub-\/templated. It seems that the A\+N\+S\+I C++ forbids the specialization of a sub-\/templated class (inner template) if the outer template is not specialized. Therefore, the size parameter must be used to template the outer class, i.\+e. \hyperlink{classvct_fixed_size_vector_recursive_engines}{vct\+Fixed\+Size\+Vector\+Recursive\+Engines}. The inner class are templated by the operation type and allows to plug any operation with a given signature.

The operation is implemented inline using ``template metaprogramming\textquotesingle{}\textquotesingle{} in a recursive form. The order of evaluation is from index 0 to index n-\/1. The operation has to be declared as a static function, which means it cannot use a third object to contain additional data, and it has to be defined in compilation time.

All vector types must support operator\mbox{[}$\,$\mbox{]}(unsigned int) to access their elements. The input vector types must have it as const method. The output vector type must have it as non-\/const method.


\begin{DoxyParams}{Parameters}
{\em size} & the size of the vector (determined at compilation time).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_vi_vi}{Vo\+Vi\+Vi} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_vi}{Vio\+Vi} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_vi_si}{Vo\+Vi\+Si} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_si_vi}{Vo\+Si\+Vi} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio_si}{Vio\+Si} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vo_vi}{Vo\+Vi} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_vio}{Vio} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_so_vi}{So\+Vi} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_so_vi_vi}{So\+Vi\+Vi} \hyperlink{classvct_fixed_size_vector_recursive_engines_1_1_so_vo_si}{So\+Vo\+Si} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/anton/devel/cisst-\/saw/cisst/cisst\+Vector/\hyperlink{vct_fixed_size_vector_recursive_engines_8h}{vct\+Fixed\+Size\+Vector\+Recursive\+Engines.\+h}\end{DoxyCompactItemize}
